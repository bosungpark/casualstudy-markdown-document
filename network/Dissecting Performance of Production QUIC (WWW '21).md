# Dissecting Performance of Production QUIC (WWW '21)

## 출처
- **제목**: Dissecting Performance of Production QUIC
- **저자**: Alexander Yu, Theophilus A. Benson (Brown University)
- **학회**: WWW '21 (The Web Conference 2021), April 19-23, Ljubljana, Slovenia
- **링크**: https://cs.brown.edu/~tab/papers/QUIC_WWW21.pdf
- **코드**: https://github.com/triplewy/quic-benchmarks

---

## AI 요약

### 연구 동기

QUIC/HTTP/3가 빠르게 채택되고 있지만, 기존 연구들은:
- 최적화되지 않은 오픈소스 서버 사용
- 제한된 페이로드만 테스트
- 서로 상충되는 결론 도출

→ **실제 프로덕션 환경**에서의 체계적 분석 필요

### 핵심 기여

1. **Google, Facebook, Cloudflare** 프로덕션 엔드포인트 벤치마크
2. 다양한 **네트워크 조건, 워크로드, 클라이언트 구현** 비교
3. 성능 차이의 **근본 원인 분석 도구** 개발
4. Facebook BBR 구현의 **버그 발견 및 수정** 기여

---

## QUIC 프로토콜 개요

### TCP와의 핵심 차이점

```
┌─────────────────────────────────────────────────────────────┐
│                    프로토콜 스택 비교                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   HTTP/2 Stack              HTTP/3 Stack                    │
│   ┌───────────┐            ┌───────────┐                    │
│   │  HTTP/2   │            │  HTTP/3   │                    │
│   ├───────────┤            ├───────────┤                    │
│   │   TLS     │            │   QUIC    │ ← TLS 내장         │
│   ├───────────┤            │  (TLS 포함)│                    │
│   │   TCP     │            ├───────────┤                    │
│   ├───────────┤            │    UDP    │                    │
│   │    IP     │            ├───────────┤                    │
│   └───────────┘            │    IP     │                    │
│                            └───────────┘                    │
│                                                             │
│   RTT: 2-3 (TCP+TLS)       RTT: 1 (QUIC+TLS 통합)          │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 1. Stream Multiplexing (HOL Blocking 제거)

```
[TCP의 HOL Blocking 문제]

   Stream 0  Stream 1  Stream 2
      ▼         ▼         ▼
  ┌───────────────────────────┐
  │   TCP (단일 바이트 스트림)   │
  └───────────────────────────┘
              │
    ┌─────────┼─────────┐
    │         │         │
  Pkt 1    Pkt 2     Pkt 3
    ✓       ✗ LOST     ✓
              │
              ▼
    Pkt 2 재전송 대기 동안
    Pkt 3도 애플리케이션에 전달 불가!


[QUIC의 해결책]

   Stream 0  Stream 1  Stream 2
      │         │         │
      ▼         ▼         ▼
  ┌───────┬───────┬───────┐
  │QUIC S0│QUIC S1│QUIC S2│  ← 독립적 스트림
  └───────┴───────┴───────┘
              │
    ┌─────────┼─────────┐
    │         │         │
  Pkt 1    Pkt 2     Pkt 3
  (S0)     (S1)✗     (S2)
              │
              ▼
    Pkt 2(S1) 손실되어도
    Pkt 3(S2)는 즉시 애플리케이션에 전달 가능!
```

### 2. Connection Establishment (핸드셰이크)

```
[TCP + TLS 1.3]                    [QUIC]

  Client         Server            Client         Server
    │               │                │               │
    │──── SYN ─────>│   1 RTT        │               │
    │<─── SYN-ACK ──│                │── Initial ───>│   1 RTT
    │──── ACK ─────>│                │<── Initial ───│
    │               │                │── Handshake ─>│
    │── ClientHello>│   1 RTT        │<─ Handshake ──│
    │<─ ServerHello │                │               │
    │── Finished ──>│                │─── Data ─────>│
    │               │                │               │
    │─── Request ──>│                                
    │               │                                
                                                     
    총: 2 RTT                        총: 1 RTT
    
    
[0-RTT Resumption]

    이전 세션 키로 즉시 데이터 전송 가능
    → 첫 패킷에 애플리케이션 데이터 포함!
```

### 3. User-space 구현의 양면성

| 장점 | 단점 |
|------|------|
| 빠른 배포/업데이트 | 커널 TCP보다 느릴 수 있음 |
| 혼잡 제어 실험 용이 | 구현마다 품질 차이 큼 |
| 플랫폼 독립적 | 최적화 어려움 |

---

## 실험 방법론

### 테스트베드 구성

```
┌──────────────────────────────────────────────────────────┐
│                      Client Side                         │
│  ┌────────────────────────────────────────────────────┐  │
│  │ MacBook Air (OSX 10.13.6)                          │  │
│  │ Intel Core i5 1.3 GHz, 8 GB RAM                    │  │
│  │ Home Internet (RTT: 10-20ms to Boston POPs)        │  │
│  └────────────────────────────────────────────────────┘  │
│                          │                               │
│            ┌─────────────┼─────────────┐                 │
│            │             │             │                 │
│            ▼             ▼             ▼                 │
│     ┌──────────┐  ┌──────────┐  ┌──────────┐            │
│     │ Chrome   │  │ Proxygen │  │ Ngtcp2   │            │
│     │ (H2/H3)  │  │ (H3)     │  │ (H3)     │            │
│     └──────────┘  └──────────┘  └──────────┘            │
│                          │                               │
│                Network Link Conditioner                  │
│                (Loss, Delay 에뮬레이션)                   │
└──────────────────────────────────────────────────────────┘
                           │
                    Internet (UDP/TCP)
                           │
┌──────────────────────────┼───────────────────────────────┐
│                     Server Side                          │
│     ┌────────────────────┼────────────────────┐          │
│     │                    │                    │          │
│     ▼                    ▼                    ▼          │
│  ┌────────┐         ┌─────────┐         ┌───────────┐   │
│  │ Google │         │Facebook │         │ Cloudflare│   │
│  │ (BBR)  │         │ (BBR)   │         │  (Cubic)  │   │
│  └────────┘         └─────────┘         └───────────┘   │
│                                                          │
│  * 2020년 12월 기준 유일한 프로덕션 QUIC 제공 업체         │
│  * QUIC v29 테스트 (최종 표준과 거의 동일)                 │
└──────────────────────────────────────────────────────────┘
```

### 테스트 파라미터

| 파라미터 | 값 |
|----------|-----|
| **대역폭** | 10 Mbps (고정) |
| **추가 손실** | 0%, 0.1%, 1% |
| **추가 지연** | 50ms, 100ms RTT |
| **단일 객체 크기** | 100KB, 1MB, 5MB |
| **웹페이지 크기** | Small (≤0.47MB), Medium (≤1.54MB), Large (≤2.83MB) |
| **반복 횟수** | 최소 40회 (통계적 유의성) |

### 성능 지표

| 지표 | 설명 | 용도 |
|------|------|------|
| **TTLB** | Time-to-Last-Byte | 단일 객체 다운로드 시간 |
| **Speed Index** | 페이지가 시각적으로 채워지는 속도 | 사용자 체감 성능 |
| **PLT** | Page Load Time | 전체 페이지 로드 완료 시간 |

---

## 핵심 발견사항

### 발견 1: QUIC의 1-RTT 이점은 작은 페이로드에서만 유의미

```
┌─────────────────────────────────────────────────────────────┐
│              100KB vs 1MB+ 페이로드 성능 비교                │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  100KB 페이로드:                                            │
│  ┌─────────────────────────────────────────────────┐        │
│  │ Google    │████████████████████│  H3 -13.9%     │        │
│  │ Facebook  │████████████████████│  H3 -14.7%     │        │
│  │ Cloudflare│████████████████████│  H3 -7.2%      │        │
│  └─────────────────────────────────────────────────┘        │
│  → QUIC의 1-RTT 핸드셰이크 이점이 크게 작용                  │
│                                                             │
│  1MB+ 페이로드:                                             │
│  ┌─────────────────────────────────────────────────┐        │
│  │ Google    │████████████████████│  H3 ≈ H2       │        │
│  │ Facebook  │████████████████████│  H3 ≈ H2       │        │
│  │ Cloudflare│████████████████████│  H3 ≈ H2       │        │
│  └─────────────────────────────────────────────────┘        │
│  → 데이터 전송 시간이 지배적, 핸드셰이크 차이 무의미         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 발견 2: 혼잡 제어 알고리즘이 성능을 결정

```
┌─────────────────────────────────────────────────────────────┐
│         Cloudflare 1MB 다운로드 @ 1% 패킷 손실               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  TCP (BBR)                          QUIC (Cubic)            │
│                                                             │
│  Bytes │                            Bytes │                 │
│  ACKed │    ____                    ACKed │      ____       │
│        │  /                               │    /            │
│        │ /                                │   /             │
│        │/                                 │  /              │
│        └────────────► Time               └──/──────► Time   │
│                                            /                │
│        빠른 복구                          /                  │
│        (손실에 강함)                   느린 시작              │
│                                       (손실에 민감)          │
│                                                             │
│  결과: TCP가 10배 더 많은 재전송에도 불구하고                │
│        QUIC보다 더 빠른 TTLB 달성!                          │
│                                                             │
│  원인: Cubic은 초기 손실 시 cwnd가 작은 상태에서             │
│        W_max를 설정 → 대역폭 활용 저하                       │
│        BBR은 손실 대신 ACK rate 기반 → 복구 빠름             │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**Cubic vs BBR 비교**:

| 특성 | Cubic | BBR |
|------|-------|-----|
| 혼잡 신호 | 패킷 손실 | ACK rate (대역폭 추정) |
| 초기 손실 대응 | cwnd 급격히 감소 | 영향 적음 |
| 랜덤 손실 환경 | 성능 저하 | 안정적 성능 |

### 발견 3: Packet Number Space 버그 (Facebook)

QUIC 고유의 **Packet Number Space** 설계가 새로운 엣지케이스를 유발:

```
┌─────────────────────────────────────────────────────────────┐
│              QUIC Packet Number Spaces                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   Initial Space ──► Handshake Space ──► 1-RTT Space        │
│   (초기 암호화)      (핸드셰이크 암호화)   (애플리케이션 암호화)│
│                                                             │
│   각 공간은:                                                │
│   • 독립적인 암호화 키 사용                                  │
│   • 독립적인 패킷 번호 사용                                  │
│   • 같은 공간 내에서만 ACK 가능                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

**발견된 버그 시나리오** (RTT > 100ms):

```
시간  │ 클라이언트              서버 (Proxygen)
      │                              
 0ms  │ ──── Initial_0 ───────►     
      │                              
55ms  │                        ◄──── Initial_0 (서버 응답)
      │                              
155ms │                        PTO 만료! (100ms 후)
      │                        ◄──── Initial_1 (probe)
      │                              
160ms │ ──── Handshake ────────►    서버: Handshake 수신
      │                              → Initial_1을 "암묵적 ACK"
      │                              → RTT = 5ms로 잘못 계산! 
      │                                (실제 RTT: 100ms+)
      │                              
      │                        BBR: 대역폭 = 데이터/RTT
      │                              → 대역폭 20배 과대평가
      │                              → cwnd 증가 중단
      │                              
      ▼                        결과: 성능 심각하게 저하
```

**버그 수정 전후 비교**:

```
100ms 추가 지연 환경에서 100KB 다운로드:

Before Fix:
  H2: ████████████████████ (기준)
  H3: ████████████████████████████████████ (+45% 느림)

After Fix:
  H2: ████████████████████ (기준)
  H3: ████████████████ (-15% 빠름)
```

### 발견 4: 클라이언트 설정이 성능에 영향

```
┌─────────────────────────────────────────────────────────────┐
│              클라이언트별 성능 차이 요인                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. SSL 인증서 검증 시간                                    │
│     Chrome: ~20ms 추가 (SSL 검증 수행)                      │
│     Proxygen/Ngtcp2: 0ms (SSL 검증 비활성화)                │
│                                                             │
│     → 100KB 다운로드 시 13-15% 성능 차이 유발               │
│                                                             │
│  2. TLS Cipher Group 호환성                                 │
│     Ngtcp2 기본: P256                                       │
│     Facebook 기본: X25519                                   │
│                                                             │
│     → 호환 안되면 1-RTT 추가 필요 (키 재협상)                │
│     → 하지만 이것이 위 버그를 우회해서 오히려 성능 향상!     │
│                                                             │
│  3. Flow Control 설정                                       │
│     Chrome: 15MB (연결), 6MB (스트림)                       │
│     Proxygen/Ngtcp2: 1GB (양쪽 모두)                        │
│                                                             │
│     → 테스트 페이로드 < 설정값이라 영향 없음                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 발견 5: HOL Blocking 제거는 실제 웹페이지에서 효과 미미

```
┌─────────────────────────────────────────────────────────────┐
│         스트림 멀티플렉싱 전략별 비교                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Cloudflare: Sequential (순차)                              │
│  ┌─────────────────────────────────────────────────┐        │
│  │ Stream 1 ████████████████                       │        │
│  │ Stream 2              ████████████████          │        │
│  │ Stream 3                              ████████  │        │
│  └─────────────────────────────────────────────────┘        │
│  → HOL Blocking 제거 효과 없음 (멀티플렉싱 안 함)            │
│                                                             │
│  Facebook: Round-Robin                                      │
│  ┌─────────────────────────────────────────────────┐        │
│  │ Stream 1 ██  ██  ██  ██                         │        │
│  │ Stream 2   ██  ██  ██  ██                       │        │
│  │ Stream 3     ██  ██  ██  ██                     │        │
│  └─────────────────────────────────────────────────┘        │
│  → 이론적으로 HOL Blocking 제거 효과 있음                   │
│                                                             │
│  Google: Batched Round-Robin                                │
│  ┌─────────────────────────────────────────────────┐        │
│  │ Stream 1 ████    ████    ████                   │        │
│  │ Stream 2     ████    ████    ████               │        │
│  │ Stream 3                         ████           │        │
│  └─────────────────────────────────────────────────┘        │
│  → 중간 형태                                                │
│                                                             │
│  실험 결과:                                                 │
│  • 1% 랜덤 손실에서도 Speed Index / PLT 차이 미미           │
│  • 혼잡 제어의 영향이 훨씬 지배적                           │
│  • (버스트 손실 패턴에서는 다를 수 있음)                    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 발견 6: 리소스 우선순위 설정 차이

```
┌─────────────────────────────────────────────────────────────┐
│           Cloudflare H2 vs H3 리소스 로딩 순서               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  [H2] - Cloudflare가 브라우저 우선순위 무시                  │
│                                                             │
│  수신 순서:                                                 │
│  ┌─────────────────────────────────────────────────┐        │
│  │ 0KB     500KB     1MB      1.5MB    2MB         │        │
│  │ ├────┬────┬────┬────┬────┬────┬────┬────┤      │        │
│  │ │img1│img2│img3│img4│MAIN│img5│img6│img7│      │        │
│  │ └────┴────┴────┴────┴────┴────┴────┴────┘      │        │
│  │                      ↑                          │        │
│  │              메인 이미지가 늦게 도착!            │        │
│  └─────────────────────────────────────────────────┘        │
│                                                             │
│  [H3] - FIFO 스케줄러 (우선순위 미구현 = 브라우저 순서 준수) │
│                                                             │
│  수신 순서:                                                 │
│  ┌─────────────────────────────────────────────────┐        │
│  │ 0KB     500KB     1MB      1.5MB    2MB         │        │
│  │ ├────┬────┬────┬────┬────┬────┬────┬────┤      │        │
│  │ │MAIN│img1│img2│img3│img4│img5│img6│img7│      │        │
│  │ └────┴────┴────┴────┴────┴────┴────┴────┘      │        │
│  │  ↑                                              │        │
│  │ 메인 이미지가 먼저 도착!                         │        │
│  └─────────────────────────────────────────────────┘        │
│                                                             │
│  결과: H3가 Speed Index에서 우수                            │
│  원인: 프로토콜 차이가 아닌 서버 설정 차이                   │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 연구 결론

### 요약 표

| 관찰 사항 | 원인 | 시사점 |
|-----------|------|--------|
| 100KB에서 H3 우수 | QUIC 1-RTT 핸드셰이크 | 프로토콜 설계의 장점 |
| 1MB+에서 동등 | 데이터 전송이 지배적 | 핸드셰이크 이점 희석 |
| Cloudflare H3 손실 시 느림 | Cubic vs BBR 차이 | 혼잡 제어 선택이 중요 |
| Facebook 지연 시 H3 느림 | 구현 버그 | User-space 구현의 위험성 |
| 클라이언트 간 차이 | TLS 설정, 인증서 검증 | 클라이언트 설정도 중요 |
| HOL Blocking 제거 효과 미미 | 혼잡 제어가 지배적 | 이론과 실제의 괴리 |

### 핵심 교훈

```
┌─────────────────────────────────────────────────────────────┐
│                    QUIC 성능 = f(?)                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│   성능 영향도:                                              │
│                                                             │
│   ████████████████████████████████ 혼잡 제어 구현 품질      │
│   ████████████████████████ 혼잡 제어 알고리즘 선택          │
│   ████████████████ 서버 설정 (우선순위, 스케줄링)           │
│   ████████████ 클라이언트 설정 (TLS, 인증서)                │
│   ████████ QUIC 프로토콜 자체 (1-RTT, HOL)                  │
│   ████ 네트워크 조건                                        │
│                                                             │
│   결론:                                                     │
│   "QUIC 배포 ≠ 자동 성능 향상"                              │
│   "구현 품질과 설정이 프로토콜보다 더 중요"                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 내가 얻은 인사이트

### 1. 프로토콜 vs 구현의 분리

이 논문의 가장 큰 기여는 **"QUIC의 혼잡 제어"**라는 표현이 부정확함을 보여준 것:

```
잘못된 표현: "QUIC's congestion control is slow"
올바른 표현: "This QUIC implementation's Cubic is slow"

같은 BBR이라도:
- Google QUIC BBR: 잘 작동
- Facebook QUIC BBR: 버그로 인해 문제
- Linux Kernel TCP BBR: 가장 안정적 (수십 년 최적화)
```

### 2. User-space의 양날의 검

```
Kernel TCP:
  + 수십 년간 최적화
  + 모든 엣지케이스 처리
  - 업데이트 느림 (OS 업그레이드 필요)

User-space QUIC:
  + 빠른 배포/실험
  + 플랫폼 독립적
  - 처음부터 구현해야 함
  - 새로운 버그 발생 가능
  - 각 구현체마다 품질 차이
```

### 3. 벤치마크의 함정

기존 연구들이 상충되는 결론을 낸 이유:

```
연구 A: "QUIC이 TCP보다 빠름"
  → 사용한 것: 최적화된 Google 서버 + 저지연 네트워크

연구 B: "QUIC이 TCP보다 느림"  
  → 사용한 것: 오픈소스 서버 + 고손실 네트워크

둘 다 맞지만, 일반화할 수 없음!
→ 프로덕션 벤치마크의 중요성
```

### 4. 이론 vs 실제

HOL Blocking 제거가 이론적으로는 큰 장점이지만:

```
이론:
  손실 시 다른 스트림 즉시 처리 가능
  → 성능 향상 기대

실제:
  1. 혼잡 제어가 손실 시 전체 전송 속도를 낮춤
  2. 개별 스트림 처리 가능해도 총 데이터량 동일
  3. 실제 손실 패턴은 랜덤보다 버스트가 많음
  
  → Speed Index / PLT 차이 미미
```

### 5. 엔지니어링 복잡성

Facebook 버그 사례가 보여주는 것:

```
새로운 기능 = 새로운 엣지케이스

QUIC의 Packet Number Space:
  - 목적: 보안 강화, 핸드셰이크 최적화
  - 부작용: RTT 측정 로직 복잡화
  - 결과: 대형 기업도 버그 유발
  
교훈: 복잡한 프로토콜은 복잡한 구현을 요구
```
