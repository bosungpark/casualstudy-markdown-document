# SCTP: Stream Control Transmission Protocol (RFC 4960)

## 출처
* 링크: https://www.rfc-editor.org/rfc/rfc4960
* 발행: 2007년 9월 (RFC 2960, RFC 3309 대체)
* 상태: Proposed Standard (현재 RFC 9260에 의해 대체됨)
* 저자: R. Stewart (Ed.)

---

## AI 요약

### 프로토콜 개요
SCTP(Stream Control Transmission Protocol)는 IP 네트워크 위에서 동작하는 신뢰성 있는 전송 프로토콜이다. 원래 PSTN(공중전화망) 시그널링 메시지를 IP 네트워크로 전송하기 위해 설계되었으나, 더 넓은 응용 분야에 활용 가능하다.

### 핵심 기능 (TCP의 한계 극복)


---

| 기능명 | 설명 | TCP와의 차이 | 실무 예시 |
| :--- | :--- | :--- | :--- |
| **멀티스트리밍**<br>(Multi-Streaming) | 하나의 연결(association) 내에서 여러 독립 스트림을 지원. 각 스트림은 자체 순서 보장, 한 스트림의 손실이 다른 스트림을 블로킹하지 않음.<br><br>**→ Head-of-Line Blocking 해결** | TCP는 단일 바이트 스트림 구조라, 한 패킷 손실 시 그 뒤 전체 데이터가 대기(전체가 블로킹). SCTP는 스트림별로 순서를 관리해, 스트림 A의 손실이 스트림 B에 영향 없음. | 실시간 미디어(음성/영상)와 제어 신호를 한 연결에서 분리해 전송. 미디어 손실이 제어 신호 지연을 유발하지 않음. |
| **멀티호밍**<br>(Multi-Homing) | 연결 양 끝점이 여러 IP 주소(인터페이스)를 등록. 기본 경로 장애 시 자동으로 다른 경로로 전환(failover)하여 연결 유지. | TCP는 한 쌍의 IP/포트만 사용, 장애 시 연결이 끊김. SCTP는 여러 경로를 미리 등록, 하트비트로 상태 감시, 장애 발생 시 무중단 전환. | 데이터센터 서버가 이중화 네트워크(공용망/사설망) 사용 시, 한 경로 장애 시 자동으로 다른 경로로 서비스 지속. |
| **메시지 경계 보존**<br>(Message Boundary Preservation) | 애플리케이션이 보낸 메시지 단위(경계)를 그대로 보존해 상대방에 전달. 한 번 보낸 메시지는 한 번에 도착(분할/합치기 불필요). | TCP는 바이트 스트림이므로, 메시지 단위가 보장되지 않음. 여러 번 보낸 데이터가 합쳐지거나 쪼개져 도착할 수 있어, 애플리케이션이 직접 경계 관리 필요. | 금융 거래, 신호 메시지 등 "한 번에 한 메시지"가 중요한 프로토콜에서 코드 단순화, 경계 오류 버그 감소. |
| **4-Way Handshake & SYN Flooding 방어** | 연결 수립 시 4단계(4-way) 핸드셰이크와 쿠키(cookie) 메커니즘 도입. 서버는 최초 요청에 리소스를 할당하지 않고, 임시 쿠키를 발급해 클라이언트가 다시 보내오면 연결 확정. | TCP는 3-way handshake에서 서버가 SYN 패킷을 받으면 곧바로 리소스 할당, SYN Flooding 공격에 취약. SCTP는 쿠키를 다시 받을 때까지 리소스 거의 사용 안 함, SYN Flooding에 강함. | 대규모 네트워크 장비, 텔코 시그널링 등에서 DoS 공격 내성 강화. |

---


### 주요 서비스 상세

| 서비스명 | 설명 | TCP와의 차이/특징 | 실무적 의미 |
| :--- | :--- | :--- | :--- |
| **신뢰성 있는 전송** | 데이터가 손실·중복 없이 정확히 도착하도록 보장. ACK, 재전송, 순서 관리 등 내장 | TCP와 유사하게 신뢰성 제공. 단, 스트림별로 독립적 관리 가능 | 금융, 시그널링 등 데이터 손실이 치명적인 환경에서 안전성 확보 |
| **데이터 단편화**<br>(Fragmentation/Reassembly) | 전송 경로의 MTU보다 큰 메시지는 자동으로 분할, 수신 측에서 재조립 | TCP는 바이트 스트림이라 애플리케이션이 직접 분할/조립 필요 없음. UDP는 직접 처리 필요 | 대용량 메시지(예: 로그, 파일)도 별도 처리 없이 안전하게 전송 |
| **순서 보장 전달**<br>(Ordered/Unordered Delivery) | 각 스트림 내에서 순서 보장. 필요시 비순서(순서 무관) 전달도 옵션 지원 | TCP는 전체 바이트 스트림 순서만 보장, SCTP는 스트림별/비순서 선택 가능 | 실시간 미디어, 이벤트 등 순서 무관 데이터에 최적화 가능 |
| **청크 번들링**<br>(Chunk Bundling) | 여러 메시지(청크)를 하나의 SCTP 패킷에 묶어 전송, 네트워크 효율 향상 | TCP는 MSS 단위로만 묶음, SCTP는 다양한 타입의 청크를 한 패킷에 혼합 가능 | 신호+데이터, 여러 이벤트를 한 번에 전송해 오버헤드 감소 |
| **네트워크 장애 허용**<br>(Failover via Multi-Homing) | 여러 IP 경로를 등록, 장애 발생 시 자동으로 대체 경로로 전환 | TCP는 단일 경로만 사용, 장애 시 재연결 필요. SCTP는 무중단 전환 | 이중화 네트워크, 고가용성 인프라에서 서비스 연속성 보장 |

---

### 패킷 구조
```
+---------------------------+
|     Common Header         |
|  (Source/Dest Port,       |
|   Verification Tag,       |
|   Checksum - CRC32c)      |
+---------------------------+
|        Chunk #1           |
+---------------------------+
|        Chunk #2           |
+---------------------------+
|          ...              |
+---------------------------+
```

### 주요 청크 타입
| 타입 | 이름 | 용도 |
|------|------|------|
| 0 | DATA | 사용자 데이터 전송 |
| 1 | INIT | 연결 초기화 |
| 2 | INIT ACK | 초기화 응답 |
| 3 | SACK | 선택적 확인응답 |
| 4 | HEARTBEAT | 경로 상태 확인 |
| 6 | ABORT | 연결 강제 종료 |
| 7 | SHUTDOWN | 정상 종료 시작 |

### 연결 설정 (4-Way Handshake)
```
Client                          Server
   |                               |
   |-------- INIT ---------------->|
   |                               |
   |<------- INIT ACK -------------|
   |       (State Cookie 포함)      |
   |                               |
   |-------- COOKIE ECHO --------->|
   |       (+ 사용자 데이터 가능)     |
   |                               |
   |<------- COOKIE ACK -----------|
   |                               |
```

### 멀티호밍 동작 방식
- 각 endpoint가 여러 IP 주소 보유 가능
- Primary Path로 일반 전송
- 장애 감지 시 대체 경로로 자동 전환
- HEARTBEAT로 경로 상태 지속 모니터링

### 혼잡 제어
- TCP와 유사한 Slow-Start, Congestion Avoidance 알고리즘
- 각 destination 주소별로 독립적인 혼잡 윈도우 관리
- Fast Retransmit, Gap Report 기반 재전송

---

## 내가 얻은 인사이트

1. **TCP의 근본적 한계 해결**: TCP가 30년 넘게 해결하지 못한 Head-of-Line Blocking 문제를 멀티스트리밍으로 해결. HTTP/2, HTTP/3(QUIC)가 이 개념을 차용함

2. **통신 인프라에서 출발한 설계**: PSTN 시그널링용으로 설계되어 신뢰성과 failover가 핵심. 이런 통신사 요구사항이 일반 인터넷 프로토콜보다 높은 수준의 안정성을 만들어냄

3. **보안 내재화**: 설계 단계부터 SYN Flooding 공격을 고려한 4-way handshake와 Cookie 메커니즘 도입. TCP는 나중에 SYN Cookie를 추가해야 했음

4. **메시지 지향 vs 스트림 지향**: 애플리케이션이 자체적으로 메시지 경계를 처리할 필요가 없어 프로토콜 설계 단순화 가능

5. **실패한 대중화의 교훈**: 기술적으로 우수하지만 NAT 통과 문제, 기존 TCP 인프라와의 호환성, 미들박스 지원 부족으로 광범위한 채택 실패. 결국 QUIC가 UDP 위에서 비슷한 기능을 구현하는 방식으로 성공

6. **RFC 9260으로 진화**: 2022년에 RFC 9260으로 업데이트됨. 20년간의 운영 경험이 반영된 개선 버전 존재

7. **현재 활용 영역**: 4G/5G 모바일 코어 네트워크(Diameter, S1-AP), WebRTC의 DataChannel(DTLS over SCTP)에서 여전히 핵심 프로토콜로 사용 중