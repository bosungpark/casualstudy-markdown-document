# Congestion Avoidance and Control (1988)

## 출처
- **제목**: Congestion Avoidance and Control
- **저자**: Van Jacobson (Lawrence Berkeley Laboratory), Michael J. Karels (UC Berkeley)
- **학회**: ACM SIGCOMM 1988
- **링크**: https://ee.lbl.gov/papers/congavoid.pdf
- **인용수**: 5,600+ (네트워크 분야 역대 최다 인용 논문 중 하나)

---

## AI 요약

### 한 줄 요약
**"인터넷이 왜 터지지 않는가?"** 에 대한 답을 제시한 논문. TCP에 혼잡 제어(Congestion Control)를 도입하여 인터넷 붕괴를 막았다.

---

### 배경: 1986년 인터넷 붕괴

1986년 10월, 인터넷에서 **혼잡 붕괴(Congestion Collapse)**가 발생했다:

> "LBL에서 UC Berkeley까지 (400야드, IMP 2홉 거리) 데이터 전송 속도가 **32 Kbps에서 40 bps로** 떨어졌다. 대역폭이 **1000배** 감소한 것이다."

**원인**: 네트워크가 혼잡해지면 패킷이 손실되고, TCP가 재전송하면서 더 많은 패킷이 네트워크에 쏟아지고, 이것이 더 큰 혼잡을 유발하는 **악순환**.

---

### 핵심 통찰: 패킷 보존 원칙 (Conservation of Packets)

Jacobson의 핵심 아이디어는 단순하다:

> **"새 패킷을 네트워크에 넣으려면, 먼저 오래된 패킷이 나가야 한다."**

이 원칙이 지켜지면 네트워크는 안정적이다. 문제는 이 원칙이 깨지는 3가지 상황:

| 문제 | 설명 | 해결책 |
|------|------|--------|
| 1. 평형 상태 도달 실패 | 연결 시작 시 갑자기 많은 패킷 전송 | **Slow Start** |
| 2. 평형 상태 유지 실패 | 잘못된 타이머로 불필요한 재전송 | **RTT 분산 추정** |
| 3. 자원 한계 | 네트워크 용량 초과 | **Congestion Avoidance** |

---

### 알고리즘 1: Slow Start (느린 시작)

**문제**: TCP 연결 시작 시, 송신자가 윈도우 크기만큼 한꺼번에 패킷을 보냄 → 네트워크 폭주

**해결**: 천천히 시작해서 네트워크 용량을 탐색
```
cwnd = 1                    # 혼잡 윈도우를 1 패킷으로 시작
for each ACK received:
    cwnd = cwnd + 1         # ACK 받을 때마다 1씩 증가
```

**효과**: 윈도우가 지수적으로 증가 (1 → 2 → 4 → 8 → ...)
```
시간(RTT)    cwnd
   0          1
   1          2
   2          4
   3          8
   n          2^n
```

**왜 "느린" 시작인가?**: 한꺼번에 윈도우 전체를 보내는 것에 비하면 느리다는 의미. 실제로는 **지수적 증가**라 꽤 빠르다.

---

### 알고리즘 2: RTT (Round-Trip Time) 분산 추정

**문제**: 기존 TCP는 평균 RTT만 계산 → 네트워크 부하 시 RTT 변동이 커지면 잘못된 타임아웃

**기존 방식 (RFC 793)**:
```
R = αR + (1-α)M       # 평균 RTT 추정
rto = βR              # β = 2
```

**문제점**: 네트워크 부하가 75%이면 RTT 변동이 **16배**까지 증가할 수 있음

**Jacobson의 해결책**: 평균 + **분산** 모두 추정
```
Err = M - A                     # 예측 오차
A = A + g × Err                 # 평균 업데이트 (g = 1/8)
V = V + g × (|Err| - V)         # 분산(편차) 업데이트
rto = A + 4V                    # 타임아웃 = 평균 + 4×편차
```

**효율적인 구현** (정수 연산, 비트 시프트 사용):
```c
m -= (sa >> 3);       // sa = 8 × 평균
sa += m;
if (m < 0) m = -m;
m -= (sv >> 2);       // sv = 4 × 편차
sv += m;
rto = (sa >> 3) + sv;
```

---

### 알고리즘 3: Congestion Avoidance (혼잡 회피)

**핵심 원칙**: AIMD (Additive Increase, Multiplicative Decrease)

| 상황 | 행동 | 수식 |
|------|------|------|
| 혼잡 없음 | **덧셈적 증가** | W = W + 1/W |
| 혼잡 발생 (패킷 손실) | **곱셈적 감소** | W = W × 0.5 |

**왜 이런 비대칭?**:
- **감소는 빨라야 함**: 혼잡은 지수적으로 악화되므로 빠르게 대응 필요
- **증가는 천천히**: 대역폭 탐색은 조심스럽게, 과도한 증가는 다시 혼잡 유발

**왜 0.5배 감소?**:
1. Slow Start가 보장: 현재 윈도우의 절반은 "동작했던" 크기
2. 새 연결이 대역폭을 나눠 가졌다고 가정하면 절반이 적절

---

### 전체 알고리즘: Slow Start + Congestion Avoidance
```
cwnd = 1                        # 혼잡 윈도우
ssthresh = 65535                # 임계값 (처음엔 큰 값)

on packet loss (timeout):
    ssthresh = cwnd / 2         # 임계값을 현재의 절반으로
    cwnd = 1                    # 윈도우를 1로 리셋
    # → Slow Start 재시작

on ACK received:
    if cwnd < ssthresh:
        cwnd = cwnd + 1         # Slow Start (지수 증가)
    else:
        cwnd = cwnd + 1/cwnd    # Congestion Avoidance (선형 증가)
```

**동작 흐름**:
```
          cwnd
           ↑
           |        /\      /\
           |       /  \    /  \
           |      /    \  /    \
ssthresh --|-----/------\/------\----
           |    /              
           |   / Slow Start
           |  /
           | /
           |/_____________________________→ time
           손실    손실
```

---

### 실험 결과

**테스트 환경**: 4개의 동시 TCP 연결이 230.4 Kbps 링크를 공유

| 지표 | Congestion Control 없음 | Congestion Control 적용 |
|------|------------------------|------------------------|
| 재전송 패킷 | 4,000 / 11,000 (36%) | 89 / 8,281 (1%) |
| 유효 대역폭 | 75% (6 KBps 손실) | 100% |
| 대역폭 공정성 | 불공정 (0.5~8 KBps) | 공정 (4.5~8 KBps) |

---

### 논문이 도입한 7가지 알고리즘

1. **RTT 분산 추정** (Round-trip-time variance estimation)
2. **지수적 재전송 백오프** (Exponential retransmit timer backoff)
3. **Slow Start**
4. **더 적극적인 ACK 정책** (수신자 측)
5. **동적 윈도우 크기 조정** (Congestion Avoidance)
6. **Karn의 알고리즘** (재전송 모호성 해결)
7. **Fast Retransmit** (중복 ACK 3개 시 즉시 재전송)

---

### 자기 시계 (Self-Clocking) 메커니즘

Jacobson이 발견한 TCP의 아름다운 특성:
```
송신자 ──► [고속 네트워크] ──► [병목 링크] ──► [고속 네트워크] ──► 수신자
                                   Pb
```

- 패킷이 병목 링크를 통과하면 **간격이 벌어짐** (Pb 간격)
- ACK도 같은 간격으로 돌아옴
- 송신자가 ACK를 받고 새 패킷을 보내면 **자동으로 병목 속도에 맞춰짐**

> "ACK가 패킷을 내보내는 '시계' 역할을 한다."

---

### 왜 이 논문이 중요한가?

1. **인터넷을 살렸다**: 1986년 혼잡 붕괴 이후, 이 알고리즘이 없었다면 인터넷은 계속 붕괴했을 것
2. **30년간 표준**: TCP Tahoe, Reno, NewReno, CUBIC 등 모든 현대 혼잡 제어의 기반
3. **단순한 해결책**: 코드 몇 줄로 1000배 성능 개선
4. **분산 제어**: 중앙 관리 없이 각 TCP 연결이 독립적으로 혼잡 제어

---
