# RFC 1958: Architectural Principles of the Internet + DARPA Design Philosophy

## 출처
- **RFC 1958**: Architectural Principles of the Internet
  - **편집자**: Brian E. Carpenter (IAB)
  - **발행**: June 1996
  - **링크**: https://datatracker.ietf.org/doc/html/rfc1958
  
- **핵심 참조 논문**: The Design Philosophy of the DARPA Internet Protocols
  - **저자**: David D. Clark (MIT)
  - **발행**: SIGCOMM '88, August 1988
  - **링크**: http://ccr.sigcomm.org/archive/1995/jan95/ccr-9501-clark.pdf

---

## AI 요약

### 이 문서들의 의의

RFC 1958은 인터넷이 25년간 진화하며 형성된 **아키텍처 원칙의 스냅샷**을 기록한 문서. Clark의 1988년 논문은 TCP/IP 설계 당시의 **원래 동기와 이유**를 설명한 원전.

> "인터넷은 Grand Plan이 아닌 진화적 방식으로 성장했다. 이 진화 과정이 기술 성공의 주된 이유 중 하나다."

### 핵심 메시지

```
┌─────────────────────────────────────────────────────────────┐
│              인터넷 아키텍처의 핵심 신조                      │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  "The goal is connectivity,                                 │
│   the tool is the Internet Protocol,                        │
│   and the intelligence is end to end                        │
│   rather than hidden in the network."                       │
│                                                             │
│  목표: 연결성                                                │
│  도구: 인터넷 프로토콜 (IP)                                  │
│  지능: 끝단에 (네트워크 내부가 아닌)                         │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## DARPA 인터넷의 설계 목표 (우선순위 순서!)

Clark의 1988년 논문에서 제시한 목표 목록. **순서가 중요** - 순서가 바뀌면 완전히 다른 아키텍처가 나왔을 것.

```
┌─────────────────────────────────────────────────────────────┐
│              DARPA 인터넷 설계 목표 (우선순위)               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 🔴 생존성 (Survivability)                               │
│     → 네트워크/게이트웨이 장애에도 통신 지속                 │
│                                                             │
│  2. 🟠 다양한 서비스 유형 지원                               │
│     → 신뢰성, 지연, 대역폭 요구사항이 다른 서비스들          │
│                                                             │
│  3. 🟡 다양한 네트워크 수용                                  │
│     → 기존 네트워크들을 있는 그대로 연결                     │
│                                                             │
│  4. 🟢 분산 관리 허용                                        │
│     → 단일 중앙 통제 없이 운영                               │
│                                                             │
│  5. 🔵 비용 효율성                                           │
│     → (하지만 위 목표들보다 낮은 우선순위)                   │
│                                                             │
│  6. 🟣 낮은 호스트 연결 비용                                 │
│     → 새 호스트 추가 용이                                    │
│                                                             │
│  7. ⚪ 자원 책임성 (Accountability)                          │
│     → (가장 낮은 우선순위 - 군사적 맥락에서)                 │
│                                                             │
└─────────────────────────────────────────────────────────────┘

⚠️ 군사적 맥락: 전시에는 자원 사용 기록보다 
   가용 자원을 빠르게 배치하는 것이 중요!
   
   상업적 배치였다면 이 순서가 반대였을 것.
```

---

## 핵심 원칙 1: Fate Sharing (운명 공유)

### 개념

```
┌─────────────────────────────────────────────────────────────┐
│                    Fate Sharing 원칙                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  "상태 정보는 그것을 사용하는 엔티티와                       │
│   같은 운명을 공유해야 한다"                                 │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ [Replication 방식 - 전통적]                         │    │
│  │                                                     │    │
│  │   Host A ←──────────────────────→ Host B            │    │
│  │              │                                      │    │
│  │        ┌─────┴─────┐                                │    │
│  │        │ 네트워크   │  ← 상태 정보 저장              │    │
│  │        │ State     │  ← 복제로 보호                 │    │
│  │        └───────────┘                                │    │
│  │                                                     │    │
│  │   문제: N개 복제본으로 N-1개 장애만 버틸 수 있음     │    │
│  │         복제 알고리즘 복잡                          │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
│  ┌─────────────────────────────────────────────────────┐    │
│  │ [Fate Sharing 방식 - 인터넷]                        │    │
│  │                                                     │    │
│  │   Host A ←──────────────────────→ Host B            │    │
│  │   (상태 보유)                       (상태 보유)      │    │
│  │        │                                 │          │    │
│  │        └────────┬─────────┬──────────────┘          │    │
│  │                 │         │                         │    │
│  │           ┌─────┴───┐ ┌───┴─────┐                   │    │
│  │           │Gateway 1│ │Gateway 2│  ← Stateless      │    │
│  │           └─────────┘ └─────────┘                   │    │
│  │                                                     │    │
│  │   장점: 무한개 중간 장애에도 버팀                   │    │
│  │         구현이 훨씬 단순                            │    │
│  └─────────────────────────────────────────────────────┘    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 결과

1. **Datagram (데이터그램)** 방식 채택 - Virtual Circuit이 아닌
2. **Stateless Gateway** - 게이트웨이는 연결 상태를 저장하지 않음
3. **호스트에 더 많은 신뢰** - 호스트가 잘못 동작하면 네트워크도 영향 받음

---

## 핵심 원칙 2: End-to-End Argument

RFC 1958이 명시적으로 Saltzer의 1984년 논문을 인용:

```
┌─────────────────────────────────────────────────────────────┐
│                   End-to-End Argument                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  "The function in question can completely and correctly     │
│   be implemented only with the knowledge and help of the    │
│   application standing at the endpoints of the              │
│   communication system."                                    │
│                                                             │
│  해당 기능은 통신 시스템의 끝점에 있는 애플리케이션의        │
│  지식과 도움으로만 완전하고 정확하게 구현될 수 있다.         │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  예시: 신뢰성 있는 전달                                     │
│                                                             │
│  ❌ 네트워크 레벨 복구                                      │
│     → 어차피 끝점에서 다시 확인해야 함                      │
│     → 중복 구현, 복잡성 증가                                │
│                                                             │
│  ✅ 끝점에서 ACK/재전송                                     │
│     → 네트워크는 단순히 데이터그램 전달                     │
│     → "한 번만 구현, 모든 네트워크에 적용"                  │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  예외: 성능 최적화                                          │
│                                                             │
│  "(Sometimes an incomplete version of the function          │
│   provided by the communication system may be useful        │
│   as a performance enhancement.)"                           │
│                                                             │
│  때로는 통신 시스템이 제공하는 불완전한 버전의 기능이       │
│  성능 향상에 유용할 수 있다.                                │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 네트워크 상태에 대한 지침

```
네트워크가 유지할 수 있는 상태:
  • 라우팅 정보
  • QoS 보장
  • 헤더 압축을 위한 세션 정보
  • 데이터 압축 히스토리

이 상태는 반드시:
  • Self-healing (자가 복구)
  • 최소화
  • 손실 시 일시적 서비스 거부만 유발 (연결성이 있다면)
  • 수동 설정 최소화
```

---

## 핵심 원칙 3: 단일 인터넷 프로토콜

```
┌─────────────────────────────────────────────────────────────┐
│           "이상적으로는 인터넷 레벨에 하나의 프로토콜만"     │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  Application  │ HTTP, SMTP, DNS, ...  │ 다양해도 됨         │
│  ─────────────┼───────────────────────┼──────────────       │
│  Transport    │ TCP, UDP, QUIC, ...   │ 다양해도 됨         │
│  ─────────────┼───────────────────────┼──────────────       │
│  Internet     │        IP             │ ⭐ 하나만!          │
│  ─────────────┼───────────────────────┼──────────────       │
│  Link         │ Ethernet, WiFi, ...   │ 다양해도 됨         │
│                                                             │
│  이유:                                                      │
│  • 경쟁적, 다중 벤더, 다중 제공자 공용 네트워크에서         │
│    균일하고 원활한 운영                                     │
│  • 하드웨어 매체와 주소 지정에서 독립                       │
│  • 새로운 전송 기술 쉽게 수용                               │
│                                                             │
│  예외:                                                      │
│  • IPv4 → IPv6 점진적 전환                                  │
│  • 근본적으로 새로운 요구사항                               │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## RFC 1958: 일반 설계 원칙

### 번호별 정리

| # | 원칙 | 설명 |
|---|------|------|
| **3.1** | 이기종 지원 | 전송 속도 7자릿수 차이, 다양한 워드 길이, 마이크로프로세서~슈퍼컴퓨터 |
| **3.2** | 하나를 선택하라 | 같은 일을 하는 여러 방법이 있으면 하나를 선택. 중복 기능 피할 것 |
| **3.3** | 확장성 | 사이트당 매우 많은 노드, 수백만 사이트로 확장 가능해야 함 |
| **3.4** | 성능과 비용 | 기능뿐 아니라 성능과 비용도 고려 |
| **3.5** | **단순하게** | 의심될 때는 가장 단순한 해결책 선택 |
| **3.6** | 모듈성 | 분리할 수 있으면 분리하라 |
| **3.7** | **완벽보다 거의 완전한 해결책** | 완벽한 해결책을 기다리기보다 거의 완전한 해결책을 지금 채택 |
| **3.8** | 옵션 최소화 | 가능하면 옵션과 파라미터 피함. 수동보다 동적 설정/협상 |
| **3.9** | **Robustness 원칙** | 보낼 때는 엄격히, 받을 때는 관대히 (Postel's Law) |
| **3.10** | 절약 | 비요청 패킷, 특히 멀티캐스트/브로드캐스트 최소화 |
| **3.11** | 순환 의존성 금지 | 예: 라우팅이 DNS에 의존하면 안 됨 (DNS 업데이트가 라우팅에 의존하므로) |
| **3.12** | 자기 설명적 객체 | 타입과 크기 포함. IANA 할당 코드만 사용 |
| **3.13** | 통일된 용어/표기법 | 비트/바이트 순서 규약 통일 |
| **3.14** | **실행 코드 우선** | 여러 개의 실행 코드 인스턴스가 있기 전에는 표준화하지 않음! |

### 핵심 격언

```
┌─────────────────────────────────────────────────────────────┐
│                    인터넷 설계 격언                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  "Keep it simple."                                          │
│  단순하게 유지하라.                                         │
│                                                             │
│  "Be strict when sending and tolerant when receiving."      │
│  보낼 때는 엄격히, 받을 때는 관대히. (Postel's Law)         │
│                                                             │
│  "Nothing gets standardised until there are                 │
│   multiple instances of running code."                      │
│  여러 개의 실행 코드가 있기 전에는 표준화하지 않는다.       │
│  → "Rough consensus and running code"                       │
│                                                             │
│  "It is better to adopt an almost complete solution now,    │
│   rather than to wait until a perfect solution can be       │
│   found."                                                   │
│  완벽한 해결책을 기다리기보다 거의 완전한 해결책을 지금.    │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 이름과 주소 원칙

```
┌─────────────────────────────────────────────────────────────┐
│                  이름/주소 설계 원칙                         │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  4.1 주소 하드코딩 금지                                     │
│      → 애플리케이션은 주소 대신 이름 사용                   │
│                                                             │
│  4.2 단일 네이밍 구조                                       │
│      → DNS                                                  │
│                                                             │
│  4.3 공개 이름은 대소문자 무관 ASCII                        │
│      → DNS 이름, 텍스트 형식 프로토콜 요소                  │
│                                                             │
│  4.4 주소는 명확해야 함 (유일)                              │
│                                                             │
│  4.5 상위 계층이 끝점을 명확히 식별 가능해야 함             │
│      → 전송 시작과 끝에서 주소가 같아야 함                  │
│      (NAT가 이 원칙을 위반함!)                              │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 보안 원칙

```
┌─────────────────────────────────────────────────────────────┐
│                      보안 설계 원칙                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  6.1 모든 설계는 IP 보안 아키텍처에 맞아야 함               │
│                                                             │
│  6.2 기밀성과 인증은 최종 사용자 책임                       │
│      → 캐리어(네트워크)가 제공하더라도 2차적                │
│      → End-to-End 원칙의 적용!                              │
│                                                             │
│  6.3 암호화 알고리즘 교체 가능하게 설계                     │
│      → 특정 알고리즘에 종속 금지                            │
│      → 사용 알고리즘 명시적 라벨링                          │
│                                                             │
│  6.4 검증된 강력한 알고리즘 선택                            │
│      → 시간의 검증을 받은 것                                │
│      → 불필요하게 비효율적이지 않은 것                      │
│                                                             │
│  6.5 상호운용을 위해 하나의 필수 알고리즘 지정              │
│      → 공통 알고리즘 없으면 보안 통신 불가                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘

⚠️ 1988년 Clark 논문에서 "security"라는 단어가 언급되지 않음!
   1996년 RFC 1958에서야 보안 섹션 추가.
   초기 인터넷은 보안을 설계 목표에 포함하지 않았음.
```

---

## Clark 논문의 추가 통찰

### 서비스 유형 (Type of Service)

```
┌─────────────────────────────────────────────────────────────┐
│              TCP/UDP 분리 이유                               │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  원래: TCP가 모든 서비스 지원하려 했음                      │
│                                                             │
│  문제 발견:                                                 │
│                                                             │
│  1. XNET (크로스 인터넷 디버거)                             │
│     → 신뢰성이 필요 없음 (장애 상황에서도 동작해야)         │
│     → TCP의 복잡성 불필요                                   │
│                                                             │
│  2. 실시간 음성                                             │
│     → 신뢰성보다 지연 변동 최소화가 중요                    │
│     → TCP의 재전송이 오히려 문제                            │
│                                                             │
│  해결:                                                      │
│  ┌─────────────┐                                            │
│  │ TCP (신뢰성)│  ← 파일 전송, 원격 로그인                  │
│  ├─────────────┤                                            │
│  │ UDP (단순)  │  ← 실시간, 디버깅, DNS                     │
│  ├─────────────┤                                            │
│  │     IP      │  ← 공통 기반 (데이터그램)                  │
│  └─────────────┘                                            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

### 비용 효율성 트레이드오프

```
End-to-End 재전송의 비용:

  [Host A] ──► Net1 ──► Net2 ──► Net3 ──► [Host B]
                              ↓
                         패킷 손실
                              
  재전송: Host A에서 다시 → Net1 → Net2 → Net3 → Host B
  
  vs. 네트워크 레벨 복구: Net3 내에서만 재전송
  
  결론: 재전송률이 1% 정도면 이 비용은 감당 가능.
        10%면 네트워크 레벨 신뢰성 향상 필요.
```

### Datagram의 세 가지 역할

```
┌─────────────────────────────────────────────────────────────┐
│                  Datagram의 역할                            │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 생존성 (Survivability)                                  │
│     → 네트워크 내부에 연결 상태 없음                        │
│     → 장애 후 재구성 용이                                   │
│                                                             │
│  2. 서비스 유형 다양성 (Building Block)                     │
│     → 신뢰성, 저지연 등 다양한 서비스 구축 가능             │
│     → Virtual Circuit은 고정된 서비스 유형                  │
│                                                             │
│  3. 최소 네트워크 가정 (Minimum Assumption)                 │
│     → 다양한 네트워크 수용 가능                             │
│     → 기존 네트워크 있는 그대로 연결                        │
│                                                             │
│  ⚠️ 오해: "애플리케이션이 데이터그램 서비스를 원해서"      │
│     → 실제로는 대부분 더 복잡한 서비스 필요                 │
│     → 데이터그램은 그것을 구축하기 위한 **블록**            │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## Constant Change (끊임없는 변화)

RFC 1958의 첫 번째 섹션:

```
┌─────────────────────────────────────────────────────────────┐
│                   Constant Change 원칙                       │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  "The principle of constant change is perhaps the only      │
│   principle of the Internet that should survive             │
│   indefinitely."                                            │
│                                                             │
│  끊임없는 변화의 원칙만이 영원히 살아남을 유일한            │
│  인터넷 원칙일 것이다.                                      │
│                                                             │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1971-1996 (25년간):                                        │
│  • 백본 속도: 1,000배 증가                                  │
│  • 호스트 수: 1,000,000배 증가                              │
│                                                             │
│  결과:                                                      │
│  • 몇 년 전 불가침이던 원칙이 오늘 폐기됨                   │
│  • 오늘 신성한 원칙이 내일 폐기될 것                        │
│                                                             │
│  비유:                                                      │
│  "도시를 철거하고 재건하는 것이 아니라,                     │
│   개별 거리와 건물을 지속적으로 갱신하는 것"                │
│                                                             │
└─────────────────────────────────────────────────────────────┘

Lord Kelvin (1895): "공기보다 무거운 비행 기계는 불가능하다."
→ 우리도 이 원칙들이 현재 이해의 스냅샷 이상이라고 
   상상하면 어리석을 것이다.
```

---

## Clark의 후기 반성 (2013년 주석)

Clark은 2013년에 1988년 논문에 주석을 달았습니다:

```
┌─────────────────────────────────────────────────────────────┐
│                  Clark의 2013년 반성                        │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  1. 보안에 대해:                                            │
│     "1988년 목록에 'security'라는 단어가 없다.              │
│      생존성 요구사항을 보안의 특수 사례로 볼 수 있지만,     │
│      원문은 악의적 행위를 암시조차 하지 않는다."            │
│                                                             │
│  2. 2008년 Future Internet Design 프로젝트에서             │
│     새로운 요구사항 목록:                                   │
│     1. 보안 및 가용성                                       │
│     2. 진화 및 관리 용이성                                  │
│     3. 경제적 실행 가능성 ← 1988년에는 거의 무시됨          │
│                                                             │
│  3. "멀티미디어"에 대해:                                    │
│     "1988년에는 잘 정의되지 않았다.                         │
│      지금은 완전히 다른 의미를 가진다."                     │
│                                                             │
│  4. End-to-End 재전송 비용에 대해:                          │
│     "이제는 패킷 헤더 비용과 End-to-End 재전송 비용을       │
│      받아들인 것 같다."                                     │
│                                                             │
└─────────────────────────────────────────────────────────────┘
```

---

## 내가 얻은 인사이트

### 1. 우선순위의 힘

```
같은 목표 목록, 다른 순서 = 완전히 다른 아키텍처

DARPA 순서:
  1. 생존성 → Fate Sharing, Datagram
  2. 서비스 다양성 → TCP/UDP 분리
  7. 책임성 → 거의 무시됨

만약 상업적 순서였다면:
  1. 책임성 → Connection-oriented, 중앙 상태
  2. 비용 효율성 → 특정 네트워크 최적화
  7. 생존성 → 중복성으로 해결
```

### 2. "단순함"의 전략적 선택

```
네트워크를 단순하게 → 끝점이 복잡
끝점을 단순하게 → 네트워크가 복잡

인터넷의 선택: 네트워크를 단순하게

이유:
  • 네트워크 재구현 비용 > 호스트 재구현 비용
  • "한 번 구현, 모든 네트워크에 적용"
  • 새 네트워크 추가 시 복잡한 기능 재구현 불필요
```

### 3. 실행 코드 우선주의

```
"Rough consensus and running code"

표준화 전에:
  ✅ 여러 개의 실행 가능한 구현
  ✅ 실제 피드백
  
표준화 후:
  ❌ 이론적 완벽함만 추구
  
교훈: 엔지니어링 피드백 > 아키텍처 원칙
```

### 4. 원칙의 위반과 진화

현대 인터넷에서 원칙 위반 사례:

| 원칙 | 위반 사례 | 이유 |
|------|-----------|------|
| End-to-End | NAT, 방화벽 | IPv4 주소 고갈, 보안 |
| Stateless Network | CDN, QoS | 성능 최적화 |
| 단일 네트워크 프로토콜 | IPv4/IPv6 공존 | 전환 기간 |
| 주소 불변 | NAT | 주소 절약 |

→ 원칙은 절대적이 아닌 **트레이드오프 가이드**

### 5. 설계 목표 누락의 대가

```
1988년 누락:
  - 보안
  - 이동성
  - 책임성/과금

2024년 결과:
  - 보안: TLS everywhere, 방화벽, IDS/IPS (애드혹 솔루션)
  - 이동성: Mobile IP (복잡한 패치)
  - 책임성: IP 주소 추적의 어려움

교훈: 초기에 빠진 목표는 나중에 훨씬 비싸게 추가됨
```
