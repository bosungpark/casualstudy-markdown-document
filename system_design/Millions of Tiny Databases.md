# Millions of Tiny Databases

## 출처

* **링크**: [https://www.usenix.org/conference/nsdi20/presentation/brooker](https://www.usenix.org/conference/nsdi20/presentation/brooker)
* **학회**: USENIX NSDI 2020
* **저자**: Marc Brooker, David Terei, et al. (Amazon Web Services)

---

## AI 요약

이 논문은 **AWS 내부 서비스들이 “거대한 분산 DB” 대신 “엄청나게 많은 소형 DB 인스턴스”를 선택하게 된 이유와 그 실제 구현 방식**을 설명한다.
핵심은 단순히 “작게 나눴다”가 아니라, **운영 단위를 데이터가 아니라 ‘데이터베이스’로 설정한 설계 전환**이다.

### 1. 문제 정의 (왜 기존 분산 DB가 안 맞았는가)

AWS 내부 서비스들의 공통 특성:

* 테넌트 수가 매우 많다 (계정, 버킷, 함수, 리소스 단위)
* 각 테넌트의 데이터는 **작고 독립적**
* 강한 격리, 예측 가능한 성능이 필요
* 장애 영향 범위를 극도로 좁혀야 함

기존 접근:

* 하나의 큰 DB + 샤딩
* 하지만 샤딩은:

  * 재조정 비용이 크고
  * noisy neighbor 문제를 만들며
  * 장애 시 blast radius가 커진다

👉 **“샤딩을 잘하자”가 아니라 “샤딩 자체를 피하자”는 결론**에 도달.

---

### 2. 핵심 아이디어: Database-per-Thing

* **각 테넌트/리소스마다 독립된 데이터베이스**
* DB 하나당 데이터 용량은 매우 작음
* 대신 DB 개수는 수백만 단위

중요한 점:

* 이 DB들은 *사용자가 직접 관리하는 개념이 아님*
* 완전히 **플랫폼 내부 추상화**

즉,

> 애플리케이션은 “DB가 어디 있는지, 어떤 노드에 붙었는지”를 모른다.

---

### 3. 시스템 설계 핵심

#### (1) DB는 최대한 단순하게

* 복잡한 분산 트랜잭션 ❌
* 크로스 DB 조인 ❌
* 고급 쿼리 엔진 ❌

→ DB는 **로컬 일관성 + 빠른 복구**에만 집중

#### (2) 어려움은 메타데이터 레이어로 이동

논문의 실질적 주인공은 DB가 아니라 **메타데이터 시스템**이다.

메타데이터가 담당하는 것:

* DB ID → 실제 물리 위치 매핑
* DB 생성 / 삭제 / 이동
* 부하 분산을 위한 DB 재배치
* 장애 시 DB 인스턴스 재할당

👉 **이 시스템이 사실상 “초대규모 컨트롤 플레인”**

#### (3) 이동 가능한 DB (Mobility)

* DB는 상태를 가진 채로 다른 노드로 이동 가능
* 이를 통해:

  * 핫스팟 완화
  * 노드 장애 처리
  * 점진적 리밸런싱 가능

중요한 포인트:

* 데이터 이동은 “샤드 재분배”가 아니라 **“DB 단위 이동”**
* 단위가 작기 때문에 비용이 낮다

---

### 4. 트레이드오프를 명시적으로 선택함

논문은 이 접근의 한계도 분명히 적는다.

의도적으로 포기한 것:

* 범용성 (general-purpose DB 아님)
* 대규모 분석 쿼리
* 복잡한 트랜잭션 모델

대신 얻은 것:

* 강력한 격리
* 예측 가능한 성능
* 작은 장애 반경
* 운영 자동화의 단순성

---

## 내가 얻은 인사이트

AWS 내부 핵심 서비스들에선 이미 표준적인 패턴이라도 한다.