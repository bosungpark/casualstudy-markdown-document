# Keeping CALM: When Distributed Consistency is Easy (CALM Theorem)

## 출처

* **링크**: [https://arxiv.org/abs/1901.01930](https://arxiv.org/abs/1901.01930) ([arXiv][1])
* **제목**: *Keeping CALM: When Distributed Consistency is Easy* ([arXiv][1])
* **저자**: Joseph M. Hellerstein, Peter Alvaro ([arXiv][1])
* **제출/개정**: 2019-01-07 제출, 2019-01-26 v2 ([arXiv][1])
* **핵심 키워드**: coordination(조정), monotonicity(단조성), confluence(합류성), CALM

---

## AI 요약

### 1) 문제의식: “언제 조정(락/합의/배리어)이 진짜로 필요한가?”

분산 시스템에서 성능/가용성을 해치는 가장 큰 비용 중 하나가 **coordination(조정)**인데, “정확한 의미(일관된 결과)를 유지하면서도 조정을 피할 수 있는 경우”를 이론적으로 딱 잘라 말하기가 어려웠다고 문제를 잡는다. ([ar5iv][2])

### 2) CALM 정리의 핵심 주장

CALM은 **Consistency As Logical Monotonicity**의 약자이고, 정리는 이렇게 말한다:

> **일관된(consistent) 결과를 조정 없이(coordination-free) 분산 구현할 수 있는 프로그램 ↔ 단조(monotonic) 논리로 표현 가능한 프로그램** ([ar5iv][2])

즉, “조정이 필요한지 여부”는 저장소 레벨의 일관성(선형화 가능성 등)보다 **프로그램 성질(단조성)**로 판별해야 한다는 관점 전환이다. ([ar5iv][2])

### 3) 직관을 주는 대표 예시 2개 (그래프 문제)

* **분산 데드락 탐지(Deadlock detection)**: “사이클이 *존재*한다”를 찾는 문제는 정보가 추가될수록 발견되는 사이클이 늘어날 뿐, 이미 발견한 사이클이 뒤집히지 않는다 → **단조적** → **조정 없이 가능** ([ar5iv][2])
* **분산 가비지 컬렉션(Garbage collection)**: “루트에서 *도달 불가능*”은 추가 정보가 오면 뒤집힐 수 있다(나중에 경로가 드러나면 ‘가비지’가 아니게 됨) → **비단조(Non-monotonic)** → **‘모든 정보가 도착했음’을 확인하는 조정이 필요** ([ar5iv][2])

이 대비가 “조정 필요성의 본질은 단조성”이라는 메시지를 가장 깔끔하게 보여준다. ([ar5iv][2])

### 4) 프로그램 일관성의 기준: Confluence(합류성)

분산 실행의 비결정성(메시지 순서/지연/배치)에도 불구하고 **최종 관측 결과(outcome)가 입력 집합만으로 결정**되면 “일관적”이라 보자고 제안한다. 이를 **confluence**로 설명하고, 메시지 전달 순서에 민감하지 않은 성질을 강조한다. ([ar5iv][2])

### 5) 실무적 함의

* “CAP 때문에 어쩔 수 없다”가 아니라, **내가 짠 로직이 단조면 조정을 안 해도 된다**는 **구성적(constructive) 가이드**를 준다. ([arXiv][1])
* 개발자는 설계를 “단조적으로 만들기” 위해 데이터 모델/연산을 바꿀 수 있다(예: 상태를 덮어쓰기보다 추가/합집합처럼 누적되는 형태로). ([ar5iv][2])

---

## 내가 얻은 인사이트

1. 조정 비용, 시스템 탓 아님. 문제/로직 성질 탓임
질문 바꿔야 함. “일관성 레벨 뭘 쓸까?”가 아니라 “내 로직 단조냐?”로 판단해야 함. 단조면 조정 필요 없음, 비단조면 조정 필요함. ([ar5iv][2])

2. 서비스 설계 체크리스트로 쓸 수 있음
LLM/에이전트/분산 워크플로우에도 똑같이 적용됨.

- 단조 패턴: 발견/추가/누적류(이벤트 추가, 탐지, 로그 수집, 규칙 매칭 등). 입력 늘어나면 결과는 늘거나 유지만 됨.
- 비단조 패턴: 부재/완전성/최소/정확히 하나류(중복 제거, 없음 판정, 최소/최대, 종료 등). 이런 건 “더 이상 정보 없음”을 알아야 해서 결국 조정 필요. ([ar5iv][2])

3. 단조성은 데이터 모델링 문제임
같은 기능도 표현 바꾸면 단조로 바뀌는 경우 많음. 예시: “최종 상태 덮어쓰기” 대신 “상태 변화 이벤트 추가, 최종 상태는 파생”으로 바꾸면 단조에 가까워짐. 분산에서 강한 정합성 요구하는 기능 설계할 땐, 먼저 비단조 강제하는 요구인지부터 점검해야 함.
