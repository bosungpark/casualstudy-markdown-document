# Hints for Computer System Design (1983)

## 출처
- **제목**: Hints for Computer System Design
- **저자**: Butler W. Lampson (Xerox PARC)
- **학회**: 9th ACM Symposium on Operating Systems Principles, 1983
- **링크**: https://www.microsoft.com/en-us/research/wp-content/uploads/2016/02/acrobat-17.pdf
- **분량**: 27페이지
- **수상**: ACM SIGOPS Hall of Fame Award (2005), 저자는 Turing Award 수상자 (1992)

---

## 한 줄 요약

**"시스템 설계는 알고리즘 설계와 다르다. 최선을 찾으려 하지 말고, 최악을 피하라."**

---

## 논문의 성격

저자가 직접 밝힌 **면책조항**:

> "이 힌트들은:
> - 새롭지 않고 (몇 개 빼고)
> - 실패 없는 레시피가 아니고
> - 시스템 설계의 법칙이 아니고
> - 정밀하게 공식화되지 않았고
> - 일관되지 않고
> - 항상 적절하지 않고
> - 모든 전문가가 승인한 것도 아니고
> - 작동한다고 보장되지도 않는다."

**그냥 힌트다.** 하지만 40년이 지난 지금도 유효하다!

---

## 구조: 2차원 매트릭스

| | 기능성 (Does it work?) | 속도 (Is it fast?) | 장애 허용 (Does it keep working?) |
|---|---|---|---|
| **완전성** | 정상/최악 분리 | 부하 제거 | End-to-end |
| **인터페이스** | 한 가지를 잘하라, 힘을 숨기지 마라 | 빠르게 만들어라 | End-to-end |
| **구현** | 하나는 버릴 각오, 비밀 유지, 좋은 아이디어 재사용 | 캐시, 힌트, 무식하게, 배경 작업 | 로그, 원자적 연산 |

---

## 핵심 힌트들

### 1. 기능성 (Functionality)

#### "한 가지를 잘하라" (Do one thing well)
> *"완벽함은 더 이상 더할 것이 없을 때가 아니라, 더 이상 뺄 것이 없을 때 도달한다."* — 생텍쥐페리

```
KISS: Keep It Simple, Stupid.
의심스러우면 빼라. (If in doubt, leave it out.)
기능을 박멸하라. (Exterminate features.)
```

**나쁜 예: Pilot vs Alto OS**
| | Alto OS | Pilot |
|---|---|---|
| 기능 | 파일 + 페이징 분리 | 가상 메모리 = 파일 |
| 코드 | 파일 900줄, 페이징 500줄 | 11,000줄 |
| 성능 | 페이지 폴트 1회 디스크 접근 | 2회 디스크 접근 |

Pilot은 "도와주려다" 더 복잡하고 느려졌다.

#### "힘을 숨기지 마라" (Don't hide power)
하위 레벨에서 빠르게 할 수 있는 것을, 상위 레벨에서 느리게 만들지 마라.

**좋은 예: Alto 파일 시스템**
- 하드웨어: 전체 실린더를 디스크 속도로 전송 가능
- 기본 파일 시스템: 연속 페이지를 디스크 속도로 전송
- 스트림 레벨: n바이트 읽기/쓰기, 전체 섹터는 디스크 속도 유지
- 결과: 스캐빈저, 패턴 검색 등이 디스크 풀 속도로 동작

#### "클라이언트에게 맡겨라" (Leave it to the client)
**좋은 예: Unix 철학**
- 작은 프로그램들이 각자 한 가지를 잘 함
- 입력 스트림 → 출력 스트림
- 조합은 클라이언트가 결정

**좋은 예: 모니터 (동기화)**
- 락과 시그널만 제공
- 버퍼 할당, 리소스 계정? 클라이언트가 알아서
- 스케줄링? 클라이언트가 조건 변수 분리해서 구현

#### "하나는 버릴 각오를 하라" (Plan to throw one away)
> *"어차피 버리게 될 것이다."* — Fred Brooks

새로운 기능의 시스템은 첫 구현을 완전히 다시 해야 만족스러운 결과가 나온다.

---

### 2. 속도 (Speed)

#### "빠르게 만들어라, 일반적이거나 강력하게 말고" (Make it fast, rather than general or powerful)

**예: RISC vs CISC**
- 프로그램의 대부분 시간: load, store, 비교, 1 더하기
- 801, RISC: 단순한 연산을 빠르게 → 같은 하드웨어로 더 빠름
- VAX 등: 복잡한 명령어 → 단순한 경우에도 느림
- 성능 차이: 2배 이상

#### "리소스를 고정 분할하라" (Split resources in a fixed way)

**예: 레지스터**
- 공유보다 전용이 빠름
- 작은 프로시저가 많은 현대 스타일: 16개 레지스터면 충분
- n개 레지스터 세트를 스택으로 → 저장/복원 최소화

#### "캐시하라" (Cache answers)
[f, x, f(x)]를 저장해서 다시 계산하지 마라.

**예: Bravo 에디터의 DisplayLine 캐시**
```
DisplayLine(document, firstChar) → (bitmap, lastChar, lastCharUsed)
```
- 화면의 각 줄마다 캐시 엔트리
- 편집으로 문자 i~j 변경 → [firstChar..lastCharUsed]가 [i..j]와 겹치면 무효화
- 대부분의 줄은 그대로 → 빠른 다시 그리기

#### "힌트를 사용하라" (Use hints)
캐시와 비슷하지만:
1. **틀릴 수 있음** → 사용 전 검증 필요
2. **연관 검색이 아님** → 직접 접근

**예: Alto/Pilot 파일 시스템**
- **진실**: 디스크 섹터의 라벨 (파일 ID + 페이지 번호)
- **힌트**: 디렉토리 (이름 → 파일 ID → 첫 페이지 주소)
- 힌트가 틀리면? 디스크 전체 스캔으로 재구성

**예: Arpanet 라우팅**
- 각 노드가 "최적 경로" 테이블 유지
- 주기적 브로드캐스트로 업데이트
- 일시적 불일치 OK → 결국 수렴

**예: Ethernet**
- 캐리어 없음 = "보내도 됨" 힌트
- 충돌 → 둘 다 멈추고, 랜덤 대기 후 재시도
- n번 연속 충돌 → 송신자 수 ≈ 2ⁿ로 추정 → 대기 시간 2ⁿ배

**예: Smalltalk 메소드 캐시**
```
Print(x, format)  // x의 타입에 따라 다른 코드 실행
```
- 첫 호출: 타입 테이블 검색 (비쌈)
- 트릭: lastType, lastProc를 코드에 저장
```
if type(x) == lastType then call lastProc
else LookupAndCall(x, "Print")  // lastType, lastProc 업데이트
```
- 적중률: **96%**
- 힌트 맞으면 일반 함수 호출만큼 빠름

#### "무식하게 하라" (Use brute force)
> *"의심스러우면, 무식하게 하라."*

**예: Belle 체스 머신**
- 정교한 전략 대신 특수 하드웨어로 이동 생성/평가
- 세계 컴퓨터 체스 챔피언 여러 번

**예: 개인용 컴퓨터 vs 시분할 시스템**
- 시분할: 더 영리하고 낭비 적음
- PC: 단순하지만 더 비용 효율적

#### "background에서 계산하라" (Compute in background)
- 인터랙티브 시스템: 응답 먼저, 나머지는 나중에
- 예: 가비지 컬렉션, 더티 페이지 쓰기, 이메일 배달

#### "안전 우선" (Safety first)
> *"Alto의 좋은 점은 밤에도 빨라지지 않는다는 것이다."* — J. Morris

- 리소스 수요가 용량의 2/3를 넘으면 서비스 급락
- 최적화보다 **재앙 회피**가 중요
- 해결책: 하드웨어는 싸다. 여유를 두어라.

**교훈: 페이징 시스템**
- 1970년대: 메모리 비쌈 → 영리한 스와핑 최적화 시도
- 결과: 아무도 성공 못함
- 해결: 메모리가 싸졌고, 단순한 demand paging으로 충분
- 중요한 것: **thrashing 방지**뿐

---

### 3. 장애 허용 (Fault-tolerance)

#### "End-to-End" (종단 간)
> *"애플리케이션 레벨의 에러 복구는 신뢰성 있는 시스템에 절대 필요하다. 다른 모든 에러 감지/복구는 논리적으로 불필요하며 순전히 성능을 위한 것이다."* — Saltzer

**예: A→B 파일 전송**
- A 디스크 → A 메모리 → 네트워크 → B 메모리 → B 디스크
- 각 단계 체크섬? 불충분 (메모리에서 오염될 수 있음)
- **유일한 해결책**: B 디스크에서 읽어서 A와 체크섬 비교
- 중간 체크는 **성능 향상**일 뿐, **정확성 보장 아님**

**예: Cambridge 시스템**
- 58MB 디스크 팩 복사: end-to-end 체크만 사용
- 에러 드물어서 20분 작업 거의 안 반복함

#### "로그로 진실을 기록하라" (Log updates)
로그는:
- 신뢰성 있게 쓰고 읽기 쉬움
- append-only → 쓰기 최소화
- 크래시 때도 유효성 보장 쉬움
- 복제, 테이프 백업 쉬움

**원칙**:
- 모든 업데이트를 [프로시저 이름, 인자]로 기록
- 프로시저는 **순수 함수**여야 함 (같은 인자 → 같은 결과)
- 복구: 로그 재생

**예: Bravo 에디터**
- 업데이트 함수 딱 2개:
  - `Replace(old: Interval, new: Interval)`
  - `ChangeProperties(where: Interval, what: FormattingOp)`
- 모든 편집 명령이 이 2개로 환원

#### "원자적 또는 재시작 가능하게" (Make actions atomic or restartable)
- **원자적**: 완료되거나 아무 효과 없거나
- **재시작 가능 (멱등)**: 부분 실행 여러 번 해도 결과 동일

**재시작 가능한 예**:
- 변수들에 값들 저장 ✅
- 변수 1 증가 ❌ (여러 번 하면 여러 번 증가)
