# Fencing off Go: Liveness and Safety for Channel-based Programming (extended version)

## 출처
- **링크**: https://arxiv.org/abs/1610.08843
- **저자**: Julien Lange, Nicholas Ng, Bernardo Toninho, Nobuko Yoshida
- **발표**: POPL 2017 (확장 버전)
- **제출일**: 2016년 10월 27일 (최종 수정: 2017년 2월 28일)

---

## AI 요약

### 배경 및 문제 정의

Go는 메시지 패싱을 통한 동시성을 일급 시민으로 다루는 프로덕션급 정적 타입 언어로, "메모리 공유로 통신하지 말고, 통신으로 메모리를 공유하라"는 철학을 따른다. 채널(channel)을 통한 goroutine 간 통신을 장려하지만, 현재 Go 런타임은 **전역 교착 상태(global deadlock)**만 감지할 수 있다.

**핵심 문제점**:
- **통신 불일치(Communication Mismatch)**: 채널에서 송신/수신 타입이 맞지 않는 경우
- **부분 교착 상태(Partial Deadlock)**: 일부 goroutine만 영구적으로 차단되어 메모리 누수를 일으키지만, 전체 프로그램은 계속 실행되는 상태
- 이러한 버그들은 **컴파일 타임에 전혀 감지되지 않음**

예를 들어, Go의 전역 교착 감지는 모든 goroutine이 차단될 때만 작동하므로, 일부 goroutine만 차단된 채 시스템이 계속 실행되는 경우를 감지하지 못한다. 이는 장기 실행 서버에서 치명적인 메모리 누수로 이어질 수 있다.

### 핵심 아이디어: Fencing

**Fencing**은 채널 사용에 대한 구문론적 제약으로, 프로그램이 **유한한 수의 서로 다른 통신 패턴**으로 구성되도록 보장한다. 이 패턴들은 무한히 반복될 수 있지만, 패턴의 종류 자체는 유한해야 한다.

**Fencing 제약의 핵심 규칙**:
1. 채널은 **반복문 내에서 생성될 수 없음** (동적으로 무한한 채널 생성 방지)
2. 재귀 함수 호출 시 채널을 매개변수로 전달하는 경우, 그 채널은 **재귀 호출 전후로 동일한 방식으로 사용**되어야 함
3. 이를 통해 무한 재귀가 있어도 **통신 패턴의 수는 유한**하게 유지

이 제약은 과도하게 제한적으로 보일 수 있지만, 실제로는 대부분의 잘 구조화된 Go 프로그램이 자연스럽게 만족하는 조건이다.

### 연구 방법론

#### 1. Behavioural Type 추론 (Type Inference)

Go 프로그램을 자동으로 분석하여 **행동 타입(Behavioural Type)**으로 변환한다. 이 타입은 프로그램의 통신 패턴을 추상화한 표현이다.

- **CCS/π-calculus 기반**: 프로세스 대수학(process calculus)의 이론적 기반을 활용
- **자동 추론**: 개발자가 타입 어노테이션을 작성할 필요 없음
- **충실한 표현**: Go의 채널 통신, goroutine 생성, select 문 등을 정확히 모델링

예를 들어, 간단한 채널 통신 `c <- v`는 송신 타입 `!T`, `<-c`는 수신 타입 `?T`로 표현된다.

#### 2. Fencing 검사 (Fencing Check)

추론된 행동 타입이 fencing 제약을 만족하는지 구문론적으로 검사한다.

- 채널 생성 위치 분석
- 재귀적 채널 사용 패턴 추적
- 위반 시 명확한 오류 메시지 제공

#### 3. Bounded Liveness/Safety 검증

Fencing이 보장된 프로그램에 대해 **bounded model checking**과 유사한 절차로 검증을 수행한다.

**Safety 검증**:
- 채널에서 송신/수신하는 데이터 타입이 일치하는지 확인
- 통신 프로토콜이 일관되게 따라지는지 확인
- 예: 한쪽은 int를 보내는데 다른 쪽은 string을 받으려 하면 감지

**Liveness 검증** (교착 상태 감지):
- 모든 가능한 실행 경로에서 **순환 종속성(circular dependency)** 탐지
- 차단된 송신자/수신자가 영원히 대기하는지 확인
- Bounded 접근: 유한한 통신 패턴을 반복적으로 펼쳐서(unfold) 분석

**검증 알고리즘**:
1. 행동 타입을 유한 상태 오토마타(finite state automaton)로 변환
2. 상태 공간 탐색을 통해 교착 상태 찾기
3. 발견된 교착 경로를 역추적하여 소스 코드 위치 보고

#### 4. 도구 구현: Gong

논문의 접근법을 구현한 도구 체인 **Gong**을 개발했다:
- Go 소스 코드 파싱
- 타입 추론 엔진 (Haskell로 구현)
- Fencing 검사기
- Liveness/Safety 검증기
- 위반 사항에 대한 상세한 오류 보고

### 실험 결과 및 평가

#### 평가 대상
- 공개된 Go 동시성 패턴 컬렉션
- Google의 Flywheel, ePaxos 구현 등 실제 프로젝트
- Rob Pike, Sameer Ajmani의 Go 동시성 패턴 예제

#### 주요 발견사항
1. **Fencing 만족도**: 테스트한 대부분의 프로그램이 fencing 제약을 자연스럽게 만족
2. **버그 발견**: 공개 코드에서 여러 개의 부분 교착 상태 발견
3. **거짓 양성(False Positive)**: 일부 안전한 프로그램도 fencing 위반으로 거부됨 (보수적 접근의 트레이드오프)
4. **성능**: 중간 규모 프로그램(수백 줄)에 대해 초 단위 내 검증 완료

#### 발견된 버그 예시
- 채널 닫힘 후 재전송 시도
- select 문에서 대칭적이지 않은 채널 사용으로 인한 부분 교착
- 재귀 함수에서 채널 사용 패턴 불일치

### 핵심 개념 정리

**세션 타입(Session Types)**:
- 통신 프로토콜을 타입으로 표현하는 이론적 프레임워크
- 이진 세션 타입: 두 프로세스 간의 일대일 통신 프로토콜
- 행동 타입은 세션 타입의 일반화로 볼 수 있음

**Bounded vs Unbounded Verification**:
- **Unbounded**: 무한한 상태 공간 탐색 (일반적으로 결정 불가능)
- **Bounded**: Fencing을 통해 상태 공간을 유한하게 제한하여 결정 가능하게 만듦
- 완전성(completeness)을 포기하는 대신 건전성(soundness)과 실용성 확보

**프로세스 대수학(Process Calculus)**:
- CCS (Calculus of Communicating Systems): Milner의 동시성 모델
- π-calculus: 동적 통신 토폴로지를 다루는 확장
- Go의 채널 통신을 이론적으로 모델링하는 기반

### 한계점

1. **표현력 제약**: Fencing을 만족하지 않는 일부 안전한 프로그램을 거부할 수 있음
2. **동적 패턴**: 런타임에 결정되는 복잡한 통신 패턴은 분석 어려움
3. **공유 메모리**: 채널 기반 통신에만 집중, 뮤텍스 등 공유 메모리 동기화는 미지원
4. **확장성**: 매우 큰 프로그램에서는 상태 폭발(state explosion) 가능

---

## 내가 얻은 인사이트

**정적 접근 (이 논문)**:
- 장점: 코드 작성 시점에 버그 발견, 모든 경로 분석, 실행 없이 검증
- 단점: Fencing 제약을 만족해야 함, 일부 안전한 코드도 거부 가능, 보수적

**동적 접근 (Uber)**:
- 장점: 실제 실행 패턴 기반, 거짓 양성 없음, 프로덕션 환경의 복잡한 시나리오 커버
- 단점: 실행된 경로만 검사, 테스트 커버리지에 의존, 런타임 오버헤드

Rust가 affine type(소유권)을 성공적으로 통합한 것처럼, Go도 세션 타입을 통합할 잠재력이 있음. 단, 고랭의 간결성을 추구하는 철학과는 잘 안맞는거 같음.

완전한(complete) 검증은 이론적으로 불가능(undecidable)하지만, bounded verification은 실용적으로 이만하면 충분하다 싶은 타협점을 제시함.
"Share memory by communicating" 철학은 정확성뿐 아니라 검증 가능성도 향상, 뮤텍스보다 채널 사용 시 정적 분석 도구의 도움을 더 많이 받을 수 있음
