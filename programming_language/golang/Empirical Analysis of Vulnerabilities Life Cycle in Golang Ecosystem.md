# Empirical Analysis of Vulnerabilities Life Cycle in Golang Ecosystem

## 출처
- **링크**: https://arxiv.org/abs/2401.00515
- **저자**: Jinchang Hu, Lyuye Zhang, Chengwei Liu, Sen Yang, Song Huang, Yang Liu
- **발표**: ICSE 2024 (IEEE/ACM 46th International Conference on Software Engineering)
- **제출일**: 2023년 12월 31일 (최종 수정: 2024년 1월 17일)
- **데이터셋**: https://sites.google.com/view/vulnerabilities-life-cycle/

---

## AI 요약

### 배경 및 문제 정의

오픈소스 소프트웨어(OSS)는 개발자들에게 큰 편의를 제공하지만, 취약점이 많다는 것이 주요 우려사항이다. 특히 Go(Golang)는 비교적 새로운 프로그래밍 언어로, 다른 패키지 관리자와는 구별되는 독특한 특징을 가진다.

**Golang의 독특한 특징**:

1. **커밋 기반 의존성**: 공식 릴리스 전에 **커밋(commit)을 의존성 버전으로 직접 사용** 가능
   - 장점: 패치 커밋을 릴리스 전에 즉시 적용 가능
   - 예: `v1.2.3-0.20191109021931-daa7c04131f5` (Pseudo-version)

2. **분산형 의존성 관리**: 각 의존성이 **별도의 저장소**에서 유지 및 배포 -> PyPI 같은 게 없음, 중앙 집중형 통제를 지향하지 않음.
   - 단점: 패치 전파 지연, 해결되지 않은 취약점 잔존 가능

**핵심 문제**:
- 66.10%의 Golang 모듈이 취약점의 영향을 받음
- 패치가 있어도 실제 적용까지 시간 지연(lag) 발생
- 이러한 지연의 원인과 메커니즘이 불분명

### 연구 목표

취약점의 전체 생명주기를 체계적으로 분석하여:
1. 취약점 도입부터 수정까지의 전체 과정 이해
2. 패치 전파를 방해하는 **두 가지 유형의 지연(lag)** 식별
3. 지연 발생 원인 분석 및 완화 방안 제시

### 연구 방법론

#### 1. 데이터 수집 프레임워크

다양한 소스에서 데이터를 수집하고 통합하는 프레임워크 구축:

**데이터 소스**:
- **Go Vulnerability Database**: 공식 취약점 데이터베이스
- **NVD (National Vulnerability Database)**: CVE 정보
- **GitHub Repositories**: 모듈별 커밋 히스토리, 릴리스 정보
- **Go Module Proxy**: 공식 모듈 인덱스 (proxy.golang.org)
- **deps.dev (Google Open Source Insights)**: 의존성 관계 데이터
- **Libraries.io**: 패키지 메타데이터

**수집 데이터**:
- 총 **2,065개의 취약점** (2009년~2023년)
- 관련 모듈 및 버전 정보
- 취약점 도입/수정 커밋 정보
- 릴리스 타임라인
- 모듈 인덱싱 시간

#### 2. 지연(Lag) 계산 알고리즘

취약점 생명주기의 각 단계에서 시간 지연을 체계적으로 계산:

**취약점 생명주기 단계**:
1. **도입 시점**: 취약점이 처음 코드에 포함된 시점
2. **패치 커밋 시점**: 취약점을 수정하는 커밋 생성
3. **릴리스 시점**: 패치가 포함된 버전 릴리스
4. **인덱싱 시점**: Go Module Proxy에 패치 버전이 인덱싱됨
5. **공개 시점**: 취약점 정보가 공식적으로 공개됨

**측정된 지연 유형**:

**Release Lag (릴리스 지연)**:
- **정의**: 패치 커밋 생성 후 해당 패치가 포함된 버전이 릴리스되기까지의 시간
- **계산**: `Release Time - Patch Commit Time`
- **의미**: 모듈 관리자가 패치를 릴리스하는 데 걸리는 시간

**Indexing Lag (인덱싱 지연)**:
- **정의**: 릴리스된 버전이 Go Module Proxy에 인덱싱되기까지의 시간
- **계산**: `Indexing Time - Release Time`
- **의미**: Go 생태계 인프라가 새 버전을 인식하는 데 걸리는 시간

#### 3. 분석 방법

**정량적 분석**:
- 지연 분포 및 통계량 (중앙값, 사분위수)
- 취약점 심각도별 지연 비교
- 모듈 인기도와 지연의 상관관계

**정성적 분석**:
- 지연 발생/미발생 사례 비교 연구
- GitHub 이슈, 커밋 메시지 분석
- 릴리스 정책 및 관행 조사

### 주요 실험 결과

#### 발견 1: 취약점의 광범위한 영향

- **66.10%의 모듈이 취약점 영향**
- 평균적으로 모듈당 여러 개의 취약점 존재
- 인기 있는 모듈일수록 취약점 발견이 많음 (더 많은 scrutiny)

#### 발견 2: 두 가지 주요 지연 메커니즘

**Release Lag (릴리스 지연)**:

**통계**:
- 중앙값: **29일**
- 75% 백분위수: **89일**
- 일부는 **1년 이상** 지연

**원인 분석**:
1. **정기 릴리스 주기 의존**: 많은 프로젝트가 고정된 릴리스 스케줄 사용
2. **수동 릴리스 프로세스**: 자동화 부족으로 인적 개입 필요
3. **릴리스 전 테스트**: 충분한 테스트 후 릴리스하려는 신중함
4. **프로젝트 활동 부족**: 유지보수가 활발하지 않은 프로젝트는 릴리스 지연

**긍정적 사례** (Release Lag 없음):
- **즉시 릴리스 정책**: 패치 후 바로 버전 릴리스
- **자동 릴리스 파이프라인**: CI/CD를 통한 자동 릴리스
- 예: Kubernetes 관련 모듈들은 평균 릴리스 지연이 현저히 낮음

**Indexing Lag (인덱싱 지연)**:

**통계**:
- 중앙값: **3일**
- 75% 백분위수: **12일**
- 일부 극단적 사례: **수개월**

**원인 분석**:
1. **수동 인덱싱 요청**: 모듈 관리자가 수동으로 `GOPROXY` 요청 필요
2. **태그 누락**: Semantic versioning 태그 없이 커밋만 있는 경우
3. **프록시 갱신 지연**: Go Module Proxy의 캐싱 및 갱신 정책
4. **비표준 버전 관리**: Pseudo-version만 사용하는 경우 인덱싱 어려움

**긍정적 사례** (Indexing Lag 없음):
- **적극적 인덱싱**: 릴리스 즉시 프록시 요청
- **Semantic versioning 준수**: 표준 `v1.2.3` 형식 태그 사용
- **CI/CD 통합**: 릴리스 시 자동으로 인덱싱 트리거

#### 발견 3: 심각도와 지연의 관계

**역설적 발견**:
- **높은 심각도 취약점이 더 긴 지연** 경향
- 이유: 철저한 테스트 및 검증 요구
- 하지만 신속한 대응이 더 중요한 경우임

#### 발견 4: Dependabot의 한계

**Dependabot의 동작**:
- Go Module Proxy 인덱스를 기반으로 최신 버전 확인
- 인덱싱되지 않은 패치 버전은 감지하지 못함

**결과**:
- Indexing Lag가 있는 경우, Dependabot이 취약점 수정을 제안하지 못함
- 개발자들이 수동으로 업데이트해야 함
- 자동 보안 업데이트의 효과성 제한

#### 발견 5: 커밋 기반 의존성의 양면성

**장점 (이론)**:
- 패치 커밋을 즉시 의존성으로 사용 가능
- 공식 릴리스를 기다릴 필요 없음

**단점 (실제)**:
- 커밋 기반 버전은 인덱싱이 불확실
- Pseudo-version 사용이 복잡하고 오류 발생 가능
- 의존성 관리 도구들이 제대로 지원하지 못함

### 권장사항 및 완화 방안

#### 1. 모듈 관리자를 위한 권장사항

**즉시 릴리스 정책**:
- 보안 패치는 다른 변경사항과 분리하여 즉시 릴리스
- Hotfix 릴리스 프로세스 확립

**자동화**:
- CI/CD 파이프라인에 자동 릴리스 통합
- 보안 패치 머지 시 자동으로 버전 태그 및 릴리스

**표준 준수**:
- Semantic versioning 엄격히 준수
- Git 태그를 `vX.Y.Z` 형식으로 일관되게 사용

**적극적 인덱싱**:
- 릴리스 후 즉시 `GOPROXY` 요청하여 인덱싱 트리거
- 릴리스 스크립트에 인덱싱 단계 포함

#### 2. Go 생태계 인프라 개선

**자동 인덱싱**:
- GitHub 릴리스 이벤트를 감지하여 자동 인덱싱
- 주요 저장소에 대한 우선 인덱싱

**취약점 데이터베이스 강화**:
- 패치 커밋 정보를 더 명확히 제공
- 인덱싱되지 않은 패치에 대한 경고

**도구 개선**:
- Dependabot 등이 커밋 기반 패치도 감지하도록 개선
- 인덱싱 지연 시 사용자에게 알림

#### 3. 개발자를 위한 권장사항

**능동적 모니터링**:
- 의존성 취약점을 정기적으로 수동 확인
- GitHub Security Advisories 구독

**커밋 기반 패치 활용**:
- 릴리스가 지연되는 경우, 패치 커밋을 직접 참조
- 예: `require github.com/example/module v1.2.3-0.20230615120000-abcdef123456`

**업스트림 기여**:
- 릴리스 지연 시 프로젝트에 릴리스 요청
- 패치가 인덱싱되도록 프록시 요청

### 핵심 개념

**Go Module Proxy**:
- 중앙집중식 모듈 캐시 및 인덱스 (proxy.golang.org)
- 모듈 가용성과 불변성 보장
- 하지만 인덱싱되지 않은 버전은 접근 불가

**Pseudo-version**:
- 커밋 기반 버전을 semantic version처럼 표현
- 형식: `vX.Y.Z-timestamp-commithash`
- 예: `v0.0.0-20191109021931-daa7c04131f5`

**Semantic Versioning (SemVer)**:
- `MAJOR.MINOR.PATCH` 형식
- PATCH: 하위 호환 버그 수정 (보안 패치 포함)
- Go 생태계의 표준 버전 관리 방식

**Technical Lag**:
- 최신 버전과 실제 사용 버전 간의 시간 차이
- 보안 관점에서 critical한 지표

**Dependency Chain**:
- 직접 의존성뿐 아니라 간접(transitive) 의존성도 취약점 영향
- Go의 최소 버전 선택(Minimal Version Selection) 알고리즘

### 한계점

1. **데이터 범위**: Go Vulnerability Database에 등록된 취약점만 분석
2. **비공개 취약점**: Zero-day 또는 아직 공개되지 않은 취약점 미포함
3. **인과관계**: 지연과 다른 요인(예: 프로젝트 크기)의 인과관계 확정 어려움
4. **시간적 편향**: 최근 취약점은 생명주기가 완료되지 않았을 수 있음

---

### 1. 분산형 vs 중앙집중형 패키지 관리의 트레이드오프

Golang의 분산형 의존성 관리는 철학적으로는 우아하지만, 보안 패치 전파에서는 심각한 문제를 야기한다.

**npm/PyPI (중앙집중형)**:
- **장점**: 패치 릴리스 즉시 모든 사용자가 접근 가능
- **장점**: 중앙 레지스트리가 취약점 정보와 패치를 일괄 관리
- **단점**: 단일 실패 지점(SPOF), 검열 가능성

**Go (분산형)**:
- **장점**: 검열 저항성, 소스 코드에 대한 직접 제어
- **단점**: Release Lag, Indexing Lag라는 이중 지연 발생
- **단점**: 각 모듈 관리자의 대응 속도에 의존

**교훈**:
- 완벽한 시스템은 없으며, 각 접근법의 약점을 보완하는 메커니즘 필요
- Go는 자유를 주지만, 그 자유에는 책임(신속한 릴리스)이 따름
- 하이브리드 접근 가능: 분산형 기반 + 중앙 취약점 모니터링

### 2. "시간"이라는 보안의 적: 지연의 복합 효과

Release Lag (29일 중앙값) + Indexing Lag (3일 중앙값) = **최소 32일 노출**

**공격자 관점**:
- 공개된 취약점 정보로 익스플로잇 개발: ~7일
- 32일 동안 패치되지 않은 시스템 공격 가능
- 실제로는 개발자가 업데이트하는 시간까지 포함하면 **수개월 노출**

**복합 위험**:
```
취약점 공개 → 익스플로잇 개발 (7일)
              ↓
릴리스 지연 (29일) ← 이 기간 동안 공격 위험 증가
              ↓
인덱싱 지연 (3일) ← Dependabot도 감지 못함
              ↓
개발자 업데이트 (수주~수개월) ← 실제 수정까지
```

**완화 전략**:
- **계층적 방어**: 각 단계의 지연을 독립적으로 최소화
- **Hotfix 문화**: 보안 패치는 예외적으로 즉시 처리
- **자동화**: 사람의 개입을 최소화하여 지연 축소

### 3. Dependabot의 맹점: 도구 의존의 위험성

Dependabot은 훌륭한 도구지만, **인덱싱된 버전만 인식**한다는 근본적 한계가 있다.

**시나리오**:
1. 취약점 CVE-YYYY-XXXXX 공개
2. 모듈 관리자가 패치 커밋 즉시 생성
3. 하지만 릴리스는 2개월 후 정기 주기에 맞춰 진행
4. Dependabot은 2개월 동안 아무 알림도 주지 않음
5. 개발자는 "Dependabot이 없으니 안전하겠지"라고 착각

**교훈**:
- **도구를 맹신하지 말 것**: Dependabot은 완벽하지 않음
- **다중 소스 모니터링**: GitHub Security Advisories, Snyk, 직접 확인 병행
- **커뮤니티 경계**: 취약점 공개 시 즉시 수동 확인

**개선 가능성**:
- Dependabot이 커밋 기반 패치도 제안하도록 개선
- "인덱싱 안 됐지만 패치 커밋은 있음" 알림 기능

### 4. 커밋 기반 의존성: 날카로운 양날의 검

Golang의 커밋 기반 의존성은 이론적으로 완벽하지만, 실무에서는 양날의 검이다.

**이론적 장점**:
- 패치 커밋이 있으면 즉시 `go.mod`에 반영 가능
- 릴리스를 기다릴 필요 없음
- 최고의 유연성

**실무적 문제**:
1. **복잡성**: Pseudo-version 문법 이해 필요
   ```go
   require github.com/example/module v1.2.3-0.20230615120000-abcdef123456
   ```
2. **도구 지원 부족**: 많은 도구가 정식 릴리스만 인식
3. **안정성 불확실**: 커밋이 충분히 테스트되었는지 불명
4. **인덱싱 문제**: 커밋은 프록시에 인덱싱 안 될 수 있음

**실용적 가이드라인**:
- **일반적 경우**: 정식 릴리스 버전 사용
- **긴급 보안 패치**: 커밋 기반 의존성으로 임시 대응
- **릴리스 촉구**: 모듈 관리자에게 정식 릴리스 요청
- **추후 전환**: 정식 릴리스 나오면 다시 표준 버전으로 전환

### 5. 오픈소스 유지보수의 현실: "누가 책임질 것인가?"

66.10%의 모듈이 취약점 영향을 받는다는 통계는 충격적이다. 이는 오픈소스 생태계의 구조적 문제를 드러낸다.

**문제의 근원**:
- 대부분의 오픈소스는 **무보수 자원봉사**로 유지
- 보안 패치의 긴급성과 관리자의 여유 시간 불일치
- "릴리스는 언제든 할 수 있으니 다음 주에..."라는 미루기

**Tragedy of the Commons**:
- 모두가 오픈소스를 쓰지만, 아무도 유지보수 비용을 지불하지 않음
- 취약점 대응은 비용이 들지만, 보상은 없음
- 결과: 지연, 방치, 포기

**가능한 해결책**:
1. **기업의 책임**: 의존하는 OSS에 재정 지원
2. **버그 바운티**: 취약점 수정에 대한 인센티브
3. **커뮤니티 협력**: 신뢰할 수 있는 메인테이너 그룹 형성
4. **자동화 투자**: 릴리스 등 반복 작업 자동화로 부담 경감

### 6. Semantic Versioning의 준수 중요성

논문은 SemVer 태그의 일관된 사용이 인덱싱 지연을 크게 줄인다고 강조한다.

**SemVer 미준수 사례**:
- 태그 없이 커밋만 사용
- `v` 접두사 누락: `1.2.3` 대신 `v1.2.3`
- 비표준 형식: `release-2023-06-15`

**결과**:
- Go Module Proxy가 인식하지 못함
- Dependabot 등 도구가 감지 실패
- 개발자들이 수동으로 찾아야 함

**베스트 프랙티스**:
```bash
# 좋은 예
git tag v1.2.4
git push origin v1.2.4

# 나쁜 예
git tag 1.2.4  # v 접두사 없음
git tag release-1.2.4  # 비표준 형식
```

**자동화**:
```yaml
# GitHub Actions로 자동 릴리스
- name: Create Release
  run: |
    VERSION=$(date +v0.0.0-%Y%m%d%H%M%S-$(git rev-parse --short HEAD))
    git tag $VERSION
    git push origin $VERSION
```

### 7. 보안 패치의 특수성: 일반 릴리스와 다르게 다뤄야

심각도 높은 취약점일수록 릴리스 지연이 더 길다는 역설적 발견은 중요한 시사점을 준다.

**현재 관행 (문제)**:
- 심각한 버그 → 더 철저한 테스트 → 더 긴 지연
- 모든 변경사항을 한 릴리스에 묶음
- 정기 릴리스 주기 엄격히 준수

**보안 최우선 관행 (권장)**:
- 보안 패치는 **별도 Hotfix 릴리스**로 즉시 배포
- 최소한의 테스트로 신속 릴리스
- 정기 릴리스와 독립적으로 처리

**릴리스 전략**:
```
정기 릴리스 (월 1회):
v1.2.0 → v1.3.0 (기능 추가, 리팩토링 등)

보안 Hotfix (즉시):
v1.2.1 (보안 패치만)
v1.2.2 (또 다른 보안 패치)

다음 정기 릴리스:
v1.3.0 (v1.2.2 포함 + 새 기능)
```

**Chrome의 사례**:
- 정기 릴리스: 6주 주기
- 보안 패치: 발견 즉시 릴리스
- 결과: 매우 빠른 보안 대응

### 8. 생태계 수준의 보안: 개별 프로젝트를 넘어

이 연구는 개별 프로젝트의 보안이 아니라 **생태계 전체의 보안**을 다룬다는 점에서 중요하다.

**생태계 관점**:
- 한 모듈의 취약점이 수천 개의 다운스트림 프로젝트에 영향
- 의존성 체인을 통한 취약점 전파
- 가장 약한 고리가 전체 보안 결정

**Supply Chain Security**:
- Go 모듈 = 소프트웨어 공급망의 구성 요소
- 릴리스 지연 = 공급망 전체의 취약점 지속
- 모든 참여자의 협력 필요

**정책적 시사점**:
- **표준화**: SemVer, 릴리스 프로세스 표준 마련
- **인센티브**: 신속한 보안 대응에 대한 인정/보상
- **도구 지원**: 생태계 차원의 취약점 모니터링 및 알림
- **교육**: 모듈 관리자들에게 보안 대응 중요성 교육

**미래 비전**:
- 취약점 공개 후 24시간 내 패치 릴리스
- 자동 인덱싱으로 즉시 사용 가능
- Dependabot 등이 즉시 감지하여 PR 생성
- 개발자들이 자동 머지 설정으로 즉시 적용
- **결과**: 취약점 노출 기간을 며칠로 단축

## 내가 얻은 인사이트

분산 모듈 관리는 생각보다 느릴 수 있다.
오픈소스 관리자가 정식 릴리즈하지 않으면 개별 사용자 입장에서는 이걸 잘 감지하기 어려움.