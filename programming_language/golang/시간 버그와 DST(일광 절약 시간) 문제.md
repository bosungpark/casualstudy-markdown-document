# 소프트웨어의 날짜/시간 버그와 DST(일광 절약 시간) 문제

## 출처
- **학술 논문**: https://rohan.padhye.org/files/datetimebugs-msr25.pdf (MSR 2025)
- **Go Issue #24551**: https://github.com/golang/go/issues/24551
- **Go Issue #35508**: https://github.com/golang/go/issues/35508
- **Go 공식 문서**: https://pkg.go.dev/time#Date

---

## AI 요약

### 1. 날짜/시간 버그의 실태 (MSR 2025 연구)

UC Berkeley 연구진이 GitHub의 오픈소스 Python 프로젝트에서 151개의 날짜/시간 버그를 분석한 연구입니다.

#### 핵심 발견

| 발견 | 설명 |
|-----|------|
| **시간대 관련 실수가 최대 원인** | 전체 날짜/시간 버그 중 가장 큰 비중 차지 |
| **날짜/시간 값의 잘못된 생성** | 대다수 버그가 값 생성 단계에서 발생 |
| **라이브러리 API에 대한 오해** | 기본 규칙이나 엣지 케이스 동작의 뉘앙스를 잘못 이해 |
| **단일 함수 내 발생, 간단한 수정** | 대부분 몇 줄의 코드 변경으로 패치 가능 |

#### 실제 피해 사례

- **미국 특허청**: 27,000개 이상의 특허에 법적으로 부정확한 만료일 할당 → 수억 달러 소송 위험
- **미국 의료 소프트웨어**: DST 전환 시 전자 건강 기록 손상 → 병원들이 연 2회 운영 중단 또는 종이 기록으로 전환
- **미 공군 F-22 Raptor (2007)**: 국제 날짜 변경선 통과 시 항법 시스템 오작동
- **뉴질랜드 주유소 (2024)**: 2월 29일(윤년) 연료 공급 시스템 실패
- **ICU 간호사 증언**: "새벽 1시~2시 사이 입력한 바이탈 기록이 시계가 되돌아갈 때 삭제됩니다. 한 시간 분량의 전자 기록이 사라지는 거예요."

---

### 2. Go 언어의 time.Date() DST 동작

#### 공식 문서 명세

Go 공식 문서에서는 다음과 같이 명시합니다:

> 일광 절약 시간 전환은 시간을 **건너뛰거나 반복**합니다.
> 
> 예를 들어, 미국에서:
> - **2011년 3월 13일 2:15am은 발생하지 않았습니다** (Spring Forward)
> - **2011년 11월 6일 1:15am은 두 번 발생했습니다** (Fall Back)
> 
> 이런 경우 시간대 선택과 따라서 시간이 **잘 정의되지 않습니다**.
> `Date`는 전환에 관련된 두 시간대 중 하나에서 올바른 시간을 반환하지만, **어느 것인지는 보장하지 않습니다**.

#### DST 문제의 두 가지 유형

| 유형 | 발생 시점 | 문제 | 예시 |
|-----|---------|-----|-----|
| **Gap (공백)** | Spring Forward | 요청한 시간이 존재하지 않음 | 2:00 AM → 3:00 AM 점프, 2:30 AM은 없음 |
| **Overlap (중복)** | Fall Back | 요청한 시간이 두 번 존재 | 1:30 AM이 두 번 발생, 어느 것인지 모호 |

---

### 3. Go Issue #24551: 존재하지 않는 시간 요청 시 동작

#### 문제 상황

```go
loc, _ := time.LoadLocation("America/Vancouver")
t := time.Date(2018, 3, 11, 2, 0, 0, 0, loc)
fmt.Println(t)
// 기대: 2018-03-11 02:00:00 -0800 PST 또는 2018-03-11 02:00:00 -0700 PDT
// 실제: 2018-03-11 01:00:00 -0800 PST ← 1시간 전으로 되돌아감!
```

2018년 3월 11일은 벤쿠버에서 PST → PDT로 전환되는 날입니다. 새벽 2:00 AM이 되면 시계가 즉시 3:00 AM으로 점프합니다. 따라서 **2:00 AM ~ 2:59 AM은 실제로 존재하지 않는 시간**입니다.

#### 예상 vs 실제 동작

| 구분 | 내용 |
|-----|------|
| **예상 A** | 2:00을 PST로 해석 → `02:00:00 -0800 PST` 출력 |
| **예상 B** | 2:00을 PDT로 해석 → `02:00:00 -0700 PDT` 출력 |
| **실제** | 2:00을 PDT로 해석하지만, **`01:00:00 -0800 PST`를 출력** |

#### Go의 내부 로직

1. 요청된 시간(2:00 AM)이 "존재하지 않는 시간"임을 감지
2. DST 전환 후의 시간대(PDT, -0700)를 적용
3. 2:00 PDT는 UTC 기준 09:00
4. 하지만 이 시점에 실제로 적용되는 시간대는 아직 PST이므로 09:00 UTC = 01:00 PST
5. 결과적으로 **요청한 시간보다 1시간 전의 시간이 반환됨**

**핵심**: Go는 에러를 발생시키지 않고 **조용히 다른 시간을 반환**합니다.

---

### 4. Go Issue #35508: 자정에 DST 전환하는 시간대

#### 문제 상황

```go
loc, _ := time.LoadLocation("America/Havana")
t := time.Date(2019, 3, 10, 0, 0, 0, 0, loc)
fmt.Println(t)
// 2019-03-10의 자정(00:00:00)은 쿠바에서 존재하지 않음!
```

#### 쿠바의 특수성

| 국가 | DST 전환 시각 | 결과 |
|-----|-------------|-----|
| 미국, 캐나다 등 대부분 | 새벽 2:00 AM | 2:00~2:59만 존재하지 않음 |
| **쿠바** | **자정 (00:00)** | **해당 날짜의 00:00이 존재하지 않음** |
| **칠레** | **자정 (00:00)** | 동일한 문제 발생 |

#### 영향받는 코드 패턴

```go
// "오늘의 시작"을 구하는 흔한 패턴 - 위험!
func startOfDay(t time.Time) time.Time {
    return time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, t.Location())
}

// 쿠바나 칠레 시간대에서 DST 전환일에 호출하면
// 00:00:00이 아닌 다른 시간이 반환될 수 있음
```

#### 재현 코드 (칠레 예시)

```go
package main

import (
    "fmt"
    "time"
)

func main() {
    loc, _ := time.LoadLocation("America/Santiago")
    
    // 칠레에서 자정에 DST가 바뀌는 날짜들
    dates := []struct{ y int; m time.Month; d int }{
        {2025, time.April, 6},
        {2025, time.September, 7},
    }
    
    for _, x := range dates {
        want := fmt.Sprintf("%04d-%02d-%02dT00:00:00", x.y, x.m, x.d)
        got := time.Date(x.y, x.m, x.d, 0, 0, 0, 0, loc)
        
        fmt.Printf("WANT: %s\n", want)
        fmt.Printf("GOT:  %s (zone=%s)\n\n", 
            got.Format(time.RFC3339), 
            got.Format("MST"))
    }
}
```

---

### 5. 안전한 코드 작성 패턴

#### ❌ 위험한 패턴

```go
// 1. 특정 시간대에서 직접 자정 생성
startOfDay := time.Date(y, m, d, 0, 0, 0, 0, loc)

// 2. DST 영향받는 시간대에서 시간 범위 계산
weekStart := now.AddDate(0, 0, -7)

// 3. 로컬 시간 기준으로 비교
if now.Hour() == 2 { ... }  // DST gap에서는 2시가 없음
```

#### ✅ 안전한 패턴

```go
// 1. UTC로 계산 후 필요시 변환
func startOfDayUTC(t time.Time) time.Time {
    t = t.UTC()
    return time.Date(t.Year(), t.Month(), t.Day(), 0, 0, 0, 0, time.UTC)
}

// 2. DST가 없는 고정 오프셋 시간대 사용
var KST = time.FixedZone("KST", 9*60*60)  // 한국은 DST 없음

// 3. 결과 검증
func safeDateInLocation(y int, m time.Month, d, hour int, loc *time.Location) time.Time {
    t := time.Date(y, m, d, hour, 0, 0, 0, loc)
    // 요청한 시간과 결과가 다른지 확인
    if t.Hour() != hour || t.Day() != d {
        // 로깅 또는 에러 처리
    }
    return t
}

// 4. 반열린구간으로 범위 표현 [start, end)
// - 경계값 중복/누락 방지
// - 쿼리: WHERE t >= start AND t < end
```

---

### 6. 권장사항 요약

| 상황 | 권장 접근법 |
|-----|-----------|
| 한국 시간(KST)만 사용 | DST가 없으므로 `time.FixedZone("KST", 9*60*60)` 사용 ✅ |
| 다중 시간대 지원 필요 | **UTC로 모든 계산 수행** 후 표시할 때만 로컬로 변환 |
| "오늘/이번 주의 시작" 계산 | 하드코딩된 `00:00:00` 대신 UTC 기준 또는 첫 유효 시간 확인 |
| 시간 범위 저장/비교 | **반열린구간 `[start, end)`** + Unix timestamp 또는 UTC |
| DB 저장 | Unix timestamp (int64) 또는 UTC 기준 `TIMESTAMP WITH TIME ZONE` |

---

## 내가 얻은 인사이트

- **Go의 `time.Date()`는 에러를 반환하지 않고 "최선의 추측"을 함** - 이는 의도된 설계이지만 직관적이지 않음
- **"자정은 항상 존재한다"는 가정은 위험** - 쿠바, 칠레 등 일부 시간대에서는 특정 날짜의 자정이 존재하지 않음
- **라이브러리가 알아서 해주겠지"는 위험한 가정** - API의 기본 동작과 엣지 케이스를 반드시 문서로 확인해야 함
- **KST만 사용하는 시스템은 DST 문제에서 안전** - 한국은 1988년 이후 DST를 사용하지 않음
- **글로벌 서비스라면 UTC 기반 설계 필수** - 저장은 UTC, 표시만 로컬로
- **시간 범위는 반열린구간 `[start, end)` 사용** - 경계값 처리가 명확해지고 버그 가능성 감소



