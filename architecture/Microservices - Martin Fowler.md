# Microservices - Martin Fowler

## 출처
- **저자**: James Lewis, Martin Fowler
- **출처**: martinfowler.com
- **날짜**: 2014년 3월 25일
- **URL**: https://martinfowler.com/articles/microservices.html

## AI 요약

### 1. 마이크로서비스의 정의
마이크로서비스 아키텍처 스타일은 **단일 애플리케이션을 작은 서비스들의 모음(suite)으로 개발**하는 접근법이다. 각 서비스는:
- **자체 프로세스에서 실행**
- **경량 메커니즘**(주로 HTTP 리소스 API)으로 통신
- **비즈니스 역량(business capabilities) 중심**으로 구축
- **완전히 자동화된 배포 기계**로 독립적으로 배포 가능
- **최소한의 중앙 집중식 관리**
- **다른 프로그래밍 언어**와 **다른 데이터 저장 기술** 사용 가능

### 2. Monolith vs Microservices

**Monolithic Application (모놀리식 애플리케이션)**
- **단일 유닛으로 빌드**된 서버 사이드 애플리케이션
- 클라이언트(HTML + JS), 데이터베이스, 서버 애플리케이션 3개 파트
- 모든 로직이 **단일 프로세스**에서 실행
- 변경 시 **전체를 리빌드하고 재배포**해야 함
- 수평 확장은 로드밸런서 뒤에서 여러 인스턴스 실행

**Monolith의 문제점**
- **변경 주기가 묶임**: 작은 부분 변경에도 전체 재배포
- **모듈 구조 유지 어려움**: 시간이 지나면서 모듈 경계가 무너짐
- **부분 스케일링 불가**: 일부만 필요해도 전체를 확장해야 함

**Microservices의 장점**
- **독립적 배포 및 확장**: 각 서비스를 독립적으로 배포/스케일
- **명확한 모듈 경계**: 서비스가 확고한 경계 제공
- **다른 프로그래밍 언어** 사용 가능
- **다른 팀**이 관리 가능

### 3. 특성 #1 - Componentization via Services (서비스를 통한 컴포넌트화)

**Component 정의**: 독립적으로 교체 가능하고 업그레이드 가능한 소프트웨어 단위

**Libraries vs Services**
- **Libraries**: 프로그램에 링크되어 in-memory 함수 호출로 통신
- **Services**: 별도 프로세스, 웹 서비스 요청/RPC로 통신

**서비스를 컴포넌트로 사용하는 이유**
1. **독립 배포 가능**: 한 서비스 변경 시 그 서비스만 재배포
2. **명시적 인터페이스**: 원격 호출 메커니즘으로 캡슐화 강제
3. **느슨한 결합**: 서비스 경계가 과도한 결합 방지

**단점**
- **원격 호출 비용**: in-process보다 비쌈 → API가 coarser-grained해야 함
- **책임 재할당 어려움**: 프로세스 경계를 넘는 변경이 더 어려움

### 4. 특성 #2 - Organized around Business Capabilities (비즈니스 역량 중심 조직)

**Conway's Law (콘웨이 법칙)**
> "시스템을 설계하는 조직은 그 조직의 커뮤니케이션 구조를 복사한 설계를 만든다" - Melvin Conway, 1968

**전통적 분할 (기술 계층별)**
- UI 팀, 서버 로직 팀, 데이터베이스 팀으로 분리
- 간단한 변경에도 **크로스 팀 프로젝트** 필요
- "Logic everywhere" 문제 발생

**마이크로서비스 분할 (비즈니스 역량별)**
- **비즈니스 영역 중심으로 서비스 분할**
- 각 서비스는 **Full-stack 구현**: UI, 스토리지, 외부 협업 포함
- **Cross-functional 팀**: UX, DB, 프로젝트 관리 등 모든 스킬 포함

**팀 크기**
- Amazon의 "Two Pizza Team" 원칙: 피자 2판으로 배불리 먹을 수 있는 팀 (최대 12명)
- 작게는 6명 팀이 6개 서비스 관리
- 모놀리스도 비즈니스 역량별로 모듈화 가능하지만, 서비스는 **팀 경계를 명확히** 유지하기 쉬움

### 5. 특성 #3 - Products not Projects (프로젝트가 아닌 제품)

**전통적 프로젝트 모델**
- 소프트웨어 전달 후 "완료"로 간주
- 유지보수 조직에 인계하고 프로젝트 팀 해산

**마이크로서비스 제품 모델**
- 팀이 **제품의 전체 생애주기**를 소유
- Amazon의 "**You build, you run it**" (만든 사람이 운영한다)
- 개발팀이 프로덕션에서 소프트웨어 동작에 **완전한 책임**
- 개발자가 사용자와 **일상적 접촉** 증가
- 지원 부담 일부 담당

**제품 마인드의 이점**
- 비즈니스 역량과의 연결 강화
- "기능 완성"이 아니라 "**비즈니스 역량을 어떻게 향상시킬까?**"에 집중
- 사용자와 서비스 개발자 간 개인적 관계 형성 용이

### 6. 특성 #4 - Smart Endpoints and Dumb Pipes (똑똑한 엔드포인트, 단순한 파이프)

**ESB (Enterprise Service Bus) 방식의 문제**
- 커뮤니케이션 메커니즘 자체에 복잡한 로직 포함
- 메시지 라우팅, 변환, 비즈니스 룰 적용 등

**마이크로서비스 방식: Smart Endpoints and Dumb Pipes**
- 애플리케이션이 **최대한 분리되고 응집력** 있게 설계
- **자체 도메인 로직 소유**
- Unix의 filter처럼 동작: 요청 받고 → 로직 적용 → 응답 생성
- **단순한 프로토콜**로 조율: RESTish 프로토콜, 경량 메시징

**주로 사용되는 2가지 프로토콜**

1. **HTTP request-response with resource APIs**
   - "Be of the web, not behind the web" (Ian Robinson)
   - 리소스 캐싱 가능 (최소한의 노력)

2. **경량 메시지 버스**
   - RabbitMQ, ZeroMQ 같은 단순 구현
   - 메시지 라우터 역할만 수행 (dumb)
   - **Smarts는 엔드포인트에** (메시지 생산/소비하는 서비스)

**주의사항**
- 모놀리스를 마이크로서비스로 전환 시 **커뮤니케이션 패턴 변경**이 핵심
- In-memory 메서드 호출을 단순 RPC로 변환하면 **Chatty communication** 발생 → 성능 저하
- **Coarser-grained 접근법** 필요

### 7. 특성 #5 - Decentralized Governance (탈중앙화된 거버넌스)

**중앙화된 거버넌스의 문제**
- **단일 기술 플랫폼 표준화** 경향
- "모든 문제가 못이 아니고, 모든 솔루션이 망치는 아니다"

**마이크로서비스의 다언어 접근**
- **적합한 도구 선택**: Node.js, C++, 다른 DB 등 자유롭게 선택
- 시스템을 이렇게 파티셔닝하면 **선택의 여지** 제공

**Netflix의 예시**
- 유용한 코드를 **라이브러리로 공유**
- Battle-tested code를 공유하여 유사 문제 해결
- Internal open source 모델 활용
- Git/GitHub로 오픈소스 관행을 사내에서도 적용

**Build it / Run it 정신**
- Amazon의 철학 확산
- 팀이 소프트웨어 운영 24/7 책임 (DevOps)
- 새벽 3시에 호출기 울리는 것이 **코드 품질에 집중**하는 강력한 동기
- 전통적 중앙화 모델과 정반대

**표준에 대한 다른 접근**
- **Battle-tested standards** 선호: HTTP, ATOM 등 오픈 표준
- IETF 같은 그룹의 표준: 여러 실제 구현체가 있을 때만 표준화
- 기업 아키텍처 그룹의 **강제된 표준(enforced standards)** 회피

### 8. 특성 #6 - Decentralized Data Management (탈중앙화된 데이터 관리)

**Conceptual Model의 탈중앙화**
- **Bounded Context** (Domain-Driven Design)
- 각 서비스마다 세계에 대한 개념 모델이 다름
- 예: 판매부의 "고객" ≠ 지원부의 "고객"

**Polyglot Persistence (다언어 영속성)**
- 모놀리스: 단일 논리적 데이터베이스 선호
- 마이크로서비스: **각 서비스가 자체 DB 관리**
- 같은 DB 기술의 다른 인스턴스 or 완전히 다른 DB 시스템
- 각 서비스에 적합한 스토리지 선택

**트랜잭션의 변화**
- 모놀리스: **트랜잭션**으로 여러 리소스 업데이트 시 일관성 보장
- 마이크로서비스: 분산 트랜잭션은 구현 어려움
- **Transactionless coordination** 강조
- **Eventual consistency** 명시적 인정
- **Compensating operations**로 문제 처리

**비즈니스와의 정합성**
- 많은 비즈니스가 빠른 응답을 위해 어느 정도 **불일치 허용**
- 실수 처리를 위한 reversal 프로세스 존재
- 실수 수정 비용 < 강한 일관성으로 잃는 비즈니스 손실

### 9. 특성 #7 - Infrastructure Automation (인프라 자동화)

**Continuous Delivery & Continuous Integration**
- 마이크로서비스를 구축하는 팀은 대부분 CD/CI 경험 보유
- **인프라 자동화 기술 광범위하게 활용**

**Build Pipeline**
- 가능한 한 많은 **자동화 테스트** 실행
- 작동하는 소프트웨어를 파이프라인 "위로" 승격
- **각 새 환경에 배포 자동화**

**배포의 변화**
- 모놀리스: 하나의 애플리케이션을 빌드, 테스트, 배포
- 마이크로서비스: 여러 애플리케이션 배포도 자동화되면 **"지루함(boring)"**
- CD의 목표: **배포를 지루하게** 만들기

**운영 환경의 차이**
- 모놀리스: 단일 배포
- 마이크로서비스: 각 서비스마다 대시보드, 로그, 모니터링 필요
- Netflix의 오픈소스 도구, Dropwizard 등 활용

### 10. 특성 #8 - Design for Failure (실패를 위한 설계)

**서비스 실패 허용 설계**
- 서비스를 컴포넌트로 사용 → **서비스 실패 허용** 설계 필수
- 공급자 unavailability로 인한 실패 가능
- 클라이언트가 **가능한 한 우아하게(gracefully) 응답**해야 함
- 모놀리스 대비 **추가 복잡성** 도입

**Netflix Simian Army**
- 평일 근무시간 중 **서비스와 데이터센터 실패 유도**
- 애플리케이션 복원력(resilience)과 모니터링 테스트
- Production에서 자동화 테스트 - 운영팀에게는 충격적

**Circuit Breaker 패턴**
- Release It! 책에서 소개
- Bulkhead, Timeout과 함께 구현
- 통신 애플리케이션 구축 시 **결정적으로 중요**
- Netflix 블로그에서 실제 적용 사례 공유

**실시간 모니터링**
- 서비스는 언제든 실패 가능 → **실패 빠르게 감지** 필수
- 가능하면 **자동으로 서비스 복원**
- **아키텍처 요소** 모니터링 (초당 DB 요청 수 등)
- **비즈니스 관련 메트릭** 모니터링 (분당 주문 수 등)
- Semantic monitoring으로 조기 경고 시스템

**Emergent Behavior (창발적 행동)**
- 마이크로서비스는 choreography와 event collaboration 선호
- 창발적 행동 발생 → 좋을 수도, **나쁠 수도** 있음
- **모니터링이 필수**: 나쁜 창발적 행동 빠르게 발견하고 수정

**동기 호출의 위험**
- 여러 동기 호출 → **Downtime의 곱셈 효과**
- Guardian: 사용자 요청당 **1개 동기 호출** 규칙
- Netflix: API에 **비동기성** 내장

### 11. 특성 #9 - Evolutionary Design (진화적 설계)

**서비스 분해는 변경 제어 도구**
- 마이크로서비스 실천자들은 진화적 설계 배경 보유
- 서비스 분해 = 변경 속도를 늦추지 않고 제어하는 도구

**컴포넌트화의 핵심 원칙**
- **독립적 교체 및 업그레이드 가능성**
- 협력자에게 영향 없이 컴포넌트를 재작성할 수 있는 지점 찾기
- 많은 마이크로서비스 그룹: 서비스를 진화시키기보다 **폐기 예상**

**The Guardian 사례**
- 모놀리스로 설계/구축했지만 **마이크로서비스 방향으로 진화**
- 모놀리스는 웹사이트의 핵심으로 유지
- **새 기능은 마이크로서비스로 추가** (모놀리스 API 사용)
- 일시적 기능(스포츠 이벤트 페이지)에 특히 유용
- 빠른 개발 언어로 신속 구축 → 이벤트 종료 후 제거

**Modularization through Change Pattern**
- **같은 시기에 변경되는 것들을 같은 모듈에** 보관
- 거의 변경되지 않는 부분 ≠ 자주 변경되는 부분 → 다른 서비스로 분리
- 두 서비스를 반복적으로 함께 변경 → **병합해야 한다는 신호**

**세밀한 릴리스 계획**
- 모놀리스: 변경 시 전체 빌드 및 배포
- 마이크로서비스: **수정한 서비스만 재배포**
- 릴리스 프로세스 단순화 및 가속화
- 단점: 한 서비스 변경이 **소비자를 깨뜨릴 수 있음**

**버저닝 회피**
- 전통적 통합: 버저닝으로 해결
- 마이크로서비스 세계: **최후의 수단으로만 버저닝 사용**
- 공급자 변경에 **가능한 한 관대하게(tolerant)** 서비스 설계
- Tolerant Reader 패턴

### 12. Microservices and SOA (마이크로서비스와 SOA)

**SOA와의 관계**
- "마이크로서비스 = 10년 전 SOA?" 질문 자주 등장
- SOA는 **너무 많은 의미**를 가짐 (Service Oriented Ambiguity)
- 대부분의 "SOA"는 마이크로서비스와 **상당히 다름**
- 주로 **ESB로 모놀리스 통합**하는 데 집중

**잘못된 SOA 구현**
- ESB에 복잡성 숨김 ("Erroneous Spaghetti Box" - Jim Webber)
- 수백만 달러를 쓰고도 가치 없는 수년간의 실패한 이니셔티브
- 변화를 적극적으로 방해하는 중앙화된 거버넌스 모델

**마이크로서비스 커뮤니티의 기원**
- 대규모 조직에서 서비스 통합 경험에서 성장
- Tolerant Reader 패턴 등
- 웹 활용 노력: **단순 프로토콜 사용**
- 중앙 표준 반발 (복잡성이 숨막힐 정도)

**SOA 라벨 논쟁**
- 일부 마이크로서비스 옹호자: SOA 라벨 완전 거부
- 다른 이들: 마이크로서비스 = **SOA의 한 형태** ("제대로 된 서비스 지향")
- 사실: SOA는 너무 다양한 의미 → **더 명확한 용어 필요**

### 13. Are Microservices the Future? (마이크로서비스가 미래인가?)

**긍정적 사례들**
- Amazon, Netflix, The Guardian, UK Government Digital Service
- realestate.com.au, Forward, comparethemarket.com, Travis CI
- 많은 조직이 오래 전부터 마이크로서비스 스타일 사용 (SOA라고 불렀지만)

**신중한 낙관론**
- 지금까지의 경험은 **긍정적**이지만...
- **충분한 시간이 지나지 않음** → 완전한 판단 불가
- 아키텍처 결정의 진짜 결과는 **수년 후에야 명확**

**성공한 팀의 모놀리스도 부패**
- 모듈성에 대한 강한 욕구를 가진 좋은 팀도
- 시간이 지나면서 모놀리스 아키텍처가 **부패(decayed)**
- 마이크로서비스는 **서비스 경계가 명시적이고 패치하기 어려워** 부패 가능성 낮다고 믿음
- 하지만 충분히 오래된 시스템을 보기 전까지는 **진정으로 평가 불가**

**마이크로서비스가 잘못될 이유**

1. **컴포넌트 경계 잘못 설정**
   - 컴포넌트화의 성공은 소프트웨어가 컴포넌트에 얼마나 잘 맞는가에 달림
   - **경계를 정확히 찾기 어려움**
   - 진화적 설계: 경계를 바로잡기 어렵다는 점 인식 → **리팩토링 용이성** 중요
   - 서비스 간 원격 통신 → **리팩토링이 훨씬 어려움**
   - 코드 이동, 인터페이스 변경 조정, 하위 호환성 계층 추가, 테스트 복잡성 증가

2. **컴포넌트가 깔끔하게 조합되지 않으면**
   - 복잡성이 컴포넌트 **내부 → 연결로 이동**할 뿐
   - 명시적이지 않고 **제어하기 어려운 곳**으로 이동
   - 작고 단순한 컴포넌트 내부는 좋아 보이지만
   - **서비스 간 지저분한 연결** 놓칠 수 있음

3. **팀 스킬 요인**
   - 새로운 기술은 **더 숙련된 팀**이 먼저 채택
   - 숙련된 팀에 효과적인 기술 ≠ 덜 숙련된 팀에 효과적
   - 서툰 팀 → 지저분한 모놀리스 구축 (많이 봄)
   - 서툰 팀 + 마이크로서비스 → 지저분함이 줄어들까? **악화될까?** (시간 필요)
   - **나쁜 팀은 항상 나쁜 시스템 만듦** → 마이크로서비스가 혼란을 줄이는지 늘리는지 판단 어려움

**MonolithFirst 조언**
- **마이크로서비스 아키텍처로 시작하지 마라**
- 대신 **모놀리스로 시작**, 모듈성 유지, 문제 생기면 마이크로서비스로 분할
- 단, 좋은 in-process 인터페이스 ≠ 좋은 서비스 인터페이스 (이 조언이 완벽하지 않은 이유)

**최종 입장**
- **신중한 낙관론**으로 작성
- 마이크로서비스 스타일이 **가치 있는 길**이라고 느낌
- 어디에 도착할지 확실하지 않음
- **현재 가진 불완전한 정보**로만 결정 가능 (소프트웨어 개발의 도전)

## 내가 얻은 인사이트

10년도 더 된 글인데 구절 구절 맞는 말